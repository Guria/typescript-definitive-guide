<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name=author content="https://github.com/nauchikus/typescript-definitive-guide">
    <meta name=description content="undefined">
    <meta name=keywords content="TypeScript">
    <meta name=generator content="https://weasyprint.org">
    <meta name=dcterms.created content="9/9/2020">
    <meta name=dcterms.modified content="9/9/2020">
    
    <link rel="stylesheet" href="workers/pdf/prism-vs.theme.css">
    <link rel="stylesheet" href="workers/pdf/prism-custom.theme.css">
    <link rel="stylesheet" href="workers/pdf/style.css">
    <link rel="stylesheet" href="workers/pdf/pages.css">
    <link rel="stylesheet" href="workers/pdf/cover.css">
    <link rel="stylesheet" href="workers/pdf/title.css">
    <link rel="stylesheet" href="workers/pdf/headings.css">
    <link rel="stylesheet" href="workers/pdf/content.css">
    <link rel="stylesheet" href="workers/pdf/code-block.css">
    
    <title>TypeScript: Подробное Руководство</title>
    
    <style>
        @page :blank {
            @top-center { content: "This page is intentionally left blank." }
            @bottom-left {content: "Ol"}
        }
        @page:right{
          @bottom-right {
            content: counter(page);
          }
        }
        .remark-highlight {
            page-break-after: avoid;
        }
        
        
    </style>
    
</head>
<body>
<div chapter="Super Pupper" class="page"><img class="book-cover" src="/home/ivan/Projects/typescript-definitive-guide/www/workers/pdf/a4-placeholder.png" alt="book-cover"/></div><div chapter="Super Pupper" class="page page_title"><div class="main-title_container">
    <p class="main-title">TypeScript</p>
    <p class="main-title">Подробное Руководство</p>
</div>
<p class="main-description">Книга и документация в одном</p>
<p class="main-date">Дата последнего обновления: <time>9/9/2020</time></p></div><div chapter="Super Pupper" class="page"><h2 id="11511111810910111511610510911111511695116105112111118951109795111115110111118101951189711410597110116110111115116105" title="Совместимость типов на основе вариантности" section="Экскурс в типизацию"><p class="h1__chapter-index">Глава 10</p><p class="h1__dot">. </p><p class="h1__title">Совместимость типов на основе вариантности</p></h2>
<h3 id="115111118109101115116105109111115116951161051121111189511097951111151101111181019511897114105971101161101111151161053511511111810910111511610510911111511695116105112111118951109795111115110111118101951189711410597110116110111115116105"><div class="h2__chapter-index">10.0</div><div class="h2__dot">. </div><div class="h2__chapter-title">Совместимость типов на основе вариантности</div></h3>
<hr>
<p>Помимо того, что совместимость типов зависит от вида типизации, которая была подробно разобрана в главе <a href="#115111118109101115116105109111115116951161051121111189511097951111151101111181019511810510097951161051121051229799105105" title="“Экскурс в типизацию - Совместимость типов на основе вида типизации”" target="_blank">“Экскурс в типизацию - Совместимость типов на основе вида типизации”</a>, она также может зависеть от такого механизма, как вариантность.</p>
<p><em>Вариантность</em> — это механизм переноса иерархии наследования типов на производные от них типы. В данном случае производные не означает <em>связанные отношением наследования</em>. Производные, скорее, означает <em>определяемые теми типами, с которых переносится наследование</em>. </p>
<p>Если вы впервые сталкиваетесь с этим понятием и определение вариантности кажется бессмысленным набором слов, то не стоит расстраиваться, эта тема очень простая, в чем вы сами скоро убедитесь.</p>
<p>В основе системы типов могут быть заложены следующие виды вариантности — <em>ковариантность</em>, <em>контравариантность</em>, <em>инвариантность</em>, <em>бивариантность</em>. Кроме того, что система типов использует механизм вариантности для своих служебных целей, она также может предоставлять разработчикам возможность управлять им зависящими от конкретного языка способами.</p>
<p>Но прежде чем познакомиться с каждым из этих видов вариантности отдельно, стоит сделать некоторые уточнения касательно иерархии наследования.</p>
<h3 id="1151111181091011151161051091111151169511610511211111895110979511111511011111810195118971141059711011611011111511610535105101114971141041051219795110971151081011001111189711010512197"><div class="h2__chapter-index">10.1</div><div class="h2__dot">. </div><div class="h2__chapter-title">Иерархия наследования</div></h3>
<hr>
<p><em>Иерархия наследования</em> — это <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)">дерево</a>, вверху которого расположен <em>корень</em>, самый <em>базовый тип</em> (<em>менее конкретный тип</em>), ниже которого располагаются его <em>подтипы</em> (<em>более конкретные типы</em>). В случаях преобразования подтипа к базовому типу говорят, что выполняется <em>восходящее преобразование</em> (<em>upcasting</em>). И наоборот, когда выполняется приведение базового типа к его подтипу, говорят, что выполняется <em>нисходящее приведение</em> (<em>downcasting</em>). Отношения между супертипом и его подтипом описываются как отношение <em>родитель-ребенок</em> (parent-child). Отношения между родителем типа и его ребенком описываются как <em>предок-потомок</em> (ancestor-descendant). Кроме того, при логическом сравнении тип, находящийся выше по дереву, больше (<code>></code>) чем тип находящийся ниже по дереву (и наоборот). Можно сказать, что <code>parent > child</code>, <code>child &#x3C; parent</code>, <code>ancestor > descendant</code>, <code>descendant &#x3C; ancestor</code>. Все это представлено на диаграмме ниже.</p>
<p><img src="../book/ru/chapters/010.(%D0%AD%D0%BA%D1%81%D0%BA%D1%83%D1%80%D1%81%20%D0%B2%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E)%20%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8/images/nominative-types-hierarchical-tree.png"></p>
<p>Этого вполне достаточно для того, чтобы приступить к разбору видов вариантности.</p>
<h3 id="11511111810910111511610510911111511695116105112111118951109795111115110111118101951189711410597110116110111115116105351071111189711410597110116110111115116"><div class="h2__chapter-index">10.2</div><div class="h2__dot">. </div><div class="h2__chapter-title">Ковариантность</div></h3>
<hr>
<p><em>Ковариантность</em> — это механизм, позволяющий использовать более конкретный тип там, где изначально предполагалось использовать менее конкретный тип. Простыми словами, совместимыми считаются типы, имеющие отношение <code>A > B</code> и <code>A = B</code>.</p>
<p><img src="../book/ru/chapters/010.(%D0%AD%D0%BA%D1%81%D0%BA%D1%83%D1%80%D1%81%20%D0%B2%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E)%20%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8/images/nominative-types-covariance-compatible.png"></p>
<p>Ковариантность не рекомендуется в местах, допускающих запись. Чтобы понять смысл этих слов, ниже представлена диаграмма, которая иллюстрирует, как через базовый тип можно добавить в массив с подтипом другой, несовместимый подтип и тем самым нарушить типобезопасность программы.</p>
<p><img src="../book/ru/chapters/010.(%D0%AD%D0%BA%D1%81%D0%BA%D1%83%D1%80%D1%81%20%D0%B2%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E)%20%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8/images/nominative-types-covariace-bad-example.png"></p>
<p>Ковариантность рекомендуется применять в местах, допускающих чтение.</p>
<h3 id="1151111181091011151161051091111151169511610511211111895110979511111511011111810195118971141059711011611011111511610535107111110116114971189711410597110116110111115116"><div class="h2__chapter-index">10.3</div><div class="h2__dot">. </div><div class="h2__chapter-title">Контравариантность</div></h3>
<hr>
<p><em>Контвариантность</em> — это противоположный ковариантности механизм, позволяющий использовать менее конкретный тип там, где изначально предполагалось использовать более конкретный тип. Другими словами, совместимыми считаются типы имеющие отношения <code>A &#x3C; B</code> и <code>A = B</code>.</p>
<p><img src="../book/ru/chapters/010.(%D0%AD%D0%BA%D1%81%D0%BA%D1%83%D1%80%D1%81%20%D0%B2%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E)%20%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8/images/nominative-types-contrvariance-compatible.png"></p>
<p>Контравариантность не рекомендуется в местах, допускающих чтение, и наоборот, рекомендуется применять в местах, допускающих запись.</p>
<h3 id="11511111810910111511610510911111511695116105112111118951109795111115110111118101951189711410597110116110111115116105351051101189711410597110116110111115116"><div class="h2__chapter-index">10.4</div><div class="h2__dot">. </div><div class="h2__chapter-title">Инвариантность</div></h3>
<hr>
<p><em>Инвариантность</em> — это механизм, позволяющий использовать только заданный тип. Совместимыми считаются только идентичные типы <code>A = A</code>.</p>
<p><img src="../book/ru/chapters/010.(%D0%AD%D0%BA%D1%81%D0%BA%D1%83%D1%80%D1%81%20%D0%B2%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E)%20%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8/images/nominative-types-invariance-compatible.png"></p>
<h3 id="1151111181091011151161051091111151169511610511211111895110979511111511011111810195118971141059711011611011111511610535981051189711410597110116110111115116"><div class="h2__chapter-index">10.5</div><div class="h2__dot">. </div><div class="h2__chapter-title">Бивариантность</div></h3>
<hr>
<p><em>Бивариантность</em> — это механизм, который является представлением всех, перечисленных ранее, видов вариантности. В его случае совместимыми считаются любые из перечисленных ранее варианты типы <code>A > B</code>, <code>A &#x3C; B</code> и <code>A = B</code>.</p>
<p><img src="../book/ru/chapters/010.(%D0%AD%D0%BA%D1%81%D0%BA%D1%83%D1%80%D1%81%20%D0%B2%20%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8E)%20%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8/images/nominative-types-bivariance-compatible.png"></p>
<p>Бивариантность является самым нетипобезопасным видом вариантности.</p>
</div><div chapter="Super Pupper" class="page"><h2 id="9897122111118121105951161051129597110121" title="Базовый Тип Any" section="Типы"><p class="h1__chapter-index">Глава 12</p><p class="h1__dot">. </p><p class="h1__title">Базовый Тип Any</p></h2>
<h3 id="9897122111118121105951161051129597110121359897122111118121105951161051129597110121"><div class="h2__chapter-index">12.0</div><div class="h2__dot">. </div><div class="h2__chapter-title">Базовый Тип Any</div></h3>
<hr>
<p>То что <em>TypeScript</em> является типизированной надстройкой над <em>JavaScript</em>, от которой после компиляции не остаётся и следа, означает, что первый перенял от второго всю его идеологию. Одним из таких моментов является разделение типов данных на типы значения (примитивные) и ссылочные типы.</p>
<p>В <em>JavaScript</em> все не объектные типы по своей природе иммутабельные. Иммутабельность означает, что значения нельзя модифицировать, а можно лишь полностью перезаписать новым значением. Из-за этого типы значения были прозваны примитивными типами.</p>
<h3 id="98971221111181211059511610511295971101213597110121954097110121419511211411110512211811110811012110595116105112"><div class="h2__chapter-index">12.1</div><div class="h2__dot">. </div><div class="h2__chapter-title">Any (any) произвольный тип</div></h3>
<hr>
<p>Все типы в <em>TypeScript</em> являются подтипами <code>any</code>, который указывается с помощью ключевого слова <code>any</code>. Это означает, что он совместим в обе стороны с любым типом данных и с точки зрения системы типов является <em>высшим типом</em> (top type). </p>
<div class="content__code">
    <div class="content__code-panel_top content__code-panel_lang_typescript">
        <span class="content_code-label_filepath"></span>
        <span class="content_code-label_lang">typescript</span>
    </div>
    <div class="remark-highlight"><pre class="language-typescript"><code><span class="token keyword">let</span> apple<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
apple <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
apple <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div>
    <div class="content__code-panel_bottom content__code-panel_lang_typescript"></div>
</div>
<p>Тип <code>any</code> в аннотации рекомендуется применять только в самых крайних случаях. К примеру объявление неинициализированной переменной, с заранее неизвестным типом, что является допустимым сценарием на ранних стадиях применения техники <code>TDD</code> при создании программы. В остальных случаях настоятельно рекомендуется прежде всего рассматривать кандидатуру обобщенных типов, которые будут рассматриваться позднее.</p>
<p>Тип <code>any</code> позволяет работать со значением динамически, что не вызывает ошибок при обращении к членам не описанных в типе данных (незадекларированных), о которых анализатор <em>TypeScript</em> ничего не знает.</p>
<p>Примером этого может служить сервис, который работает с сервером посредством <em>API</em>. Полученные и сериализованные данные могут храниться как тип <code>any</code> прежде чем они будут и преобразованы к конкретному типу.</p>
<div class="content__code">
    <div class="content__code-panel_top content__code-panel_lang_typescript">
        <span class="content_code-label_filepath"></span>
        <span class="content_code-label_lang">typescript</span>
    </div>
    <div class="remark-highlight"><pre class="language-typescript"><code><span class="token keyword">let</span> data<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'{"id": "abc"}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> id <span class="token operator">=</span> data<span class="token punctuation">.</span>id<span class="token punctuation">;</span> <span class="token comment">// ок</span>
</code></pre></div>
    <div class="content__code-panel_bottom content__code-panel_lang_typescript"></div>
</div>
<p>Если при объявлении переменных <code>var</code> и <code>let</code> и полей, объявленных в теле класса, не было присвоено значение, компилятором будет выведен тип данных <code>any</code>.</p>
<div class="content__code">
    <div class="content__code-panel_top content__code-panel_lang_typescript">
        <span class="content_code-label_filepath"></span>
        <span class="content_code-label_lang">typescript</span>
    </div>
    <div class="remark-highlight"><pre class="language-typescript"><code><span class="token keyword">var</span> apple<span class="token punctuation">;</span> <span class="token comment">// apple: any</span>
<span class="token keyword">let</span> lemon<span class="token punctuation">;</span> <span class="token comment">// lemon: any</span>

<span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">;</span> <span class="token comment">// name: any</span>
<span class="token punctuation">}</span>
</code></pre></div>
    <div class="content__code-panel_bottom content__code-panel_lang_typescript"></div>
</div>
<p>То же правило касается и параметров функций.</p>
<div class="content__code">
    <div class="content__code-panel_top content__code-panel_lang_typescript">
        <span class="content_code-label_filepath"></span>
        <span class="content_code-label_lang">typescript</span>
    </div>
    <div class="remark-highlight"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">weight</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// fruit: any</span>

<span class="token punctuation">}</span>
</code></pre></div>
    <div class="content__code-panel_bottom content__code-panel_lang_typescript"></div>
</div>
<p>Кроме того, если функция возвращает значение, принадлежащее к типу, который компилятор не в состоянии вывести, то возвращаемый этой функцией тип данных будет также будет выведен как тип <code>any</code>.</p>
<div class="content__code">
    <div class="content__code-panel_top content__code-panel_lang_typescript">
        <span class="content_code-label_filepath"></span>
        <span class="content_code-label_lang">typescript</span>
    </div>
    <div class="remark-highlight"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// function sum(a: any, b: any): any</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div>
    <div class="content__code-panel_bottom content__code-panel_lang_typescript"></div>
</div>
<p>Тип <code>any</code> является уникальным для <em>TypeScript</em>, в <em>JavaScript</em> подобного типа не существует.</p>
<h3 id="989712211111812110595116105112959711012135105116111103"><div class="h2__chapter-index">12.2</div><div class="h2__dot">. </div><div class="h2__chapter-title">Итог</div></h3>
<ul>
<li>Тип данных <code>any</code> является супертипом для всех типов в <em>TypeScript</em> и указывается с помощью ключевого слова <code>any</code>.</li>
<li>Тип данных <code>any</code> указывается тогда, когда тип данных заранее неизвестен.</li>
<li>Тип данных <code>any</code> указывается только в самых крайних случаях.</li>
<li>Тип данных <code>any</code> позволяет обращаться к незадекларированным членам объектов, имитируя динамическое поведение, тем самым перекладывая ответственность за проверку реализации интерфейса на разработчика.</li>
</ul>
</div>
</body>
</html>