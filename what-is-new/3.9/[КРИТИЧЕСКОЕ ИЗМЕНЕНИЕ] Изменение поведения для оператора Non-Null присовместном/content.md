После того, как начиная с версии `3.7` был реализован оператор опциональной последовательности (`.?`), функционал определенный стандартом _ESMAScript_, многие обратили внимание на нелогичность его поведения при совместном использовании с таким оператором, как `Not-Null\Not-Undefined`.

`````typescript
type T = {
    f0?: {
        f1?: any;
    }
}

function f(p?:T){
    p?.f0!.f1;
}

f({});
`````

Как известно, оператор опциональной последовательности предпологает предотвращение выполнения цепочки вызовов и поскольку в коде выше в функцию `f` передается объект лишенный хоть каких-то опциональных признаков типа `T`, то ошибки при обращении к полю `f1` через нулевую ссылку ассоциированную с полем `f0` не произойдет.

То есть предполагается что подобный код после компиляции примет следующий вид -

`````javascript
function f(p){
    /**
     * Обращение к f1 произойдет только в случае
     * существования параметра p и определения в
     * нем поля f0 ссылающегося на объект.
     *//
    p === null || p === void 0 ? void 0 : p.f0.f1;
}

`````

И это логично!

Но до текущей версии подобный код разворачивался таким образом что приводило к ошибке во время выполнения.

`````javascript
function f(p){
    /**
     * Обращение к f1 произойдет даже в случае
     * если параметр p и\или поле f1 отсутствует,
     * что приведет к ошибке во время выполнения.
     * Кроме того подобное поведение в корне противоречит
     * ожижидаемому разработчиком поведению оператора
     * опциональной последовательности.
     */
     (p === null || p === void 0 ? void 0 : p.f0).f1;
}

`````

Исходя из этого начиная с версии `3.9` поведение оператора `Not-Null\Not-Undefined` используемого совместно с оператором опциональной цепочки быломизменнено на ожидаемое. В случае необходимости получения поведения предшествующего текущей версии предлагается конкретизировать выражение с помощью фигурных скобок.

`````typescript
type T = {
    f0?: {
        f1?: any;
    }
}

function f(p?:T){
    /**
     * Указываем что обращение к полю f1
     * должно произойти независимо от результата
     * выражения в круглых скобках.
     * 
     * После компиляции данный код примет подобный вид -
     * 
     * (p === null || p === void 0 ? void 0 : p.f0).f1;
     */
    (p?.f0)!.f1;
}

f({});
`````
