{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/obobshcheniya (generics)","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Обобщения (Generics)","section":"Типы","path":"obobshcheniya (generics)","subtitles":[{"subtitle":"Обобщения - общие понятия","path":"obobshcheniya (generics)#obobshcheniya - obshchie ponyatiya"},{"subtitle":"Обобщения в TypeScript","path":"obobshcheniya (generics)#obobshcheniya v typescript"},{"subtitle":"Параметры типа - extends (generic constraints)","path":"obobshcheniya (generics)#parametry tipa - extends (generic constraints)"},{"subtitle":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"obobshcheniya (generics)#parametra tipa - znachenie po umolchaniu = (generic parameter defaults)"},{"subtitle":"Параметры типа - как тип данных","path":"obobshcheniya (generics)#parametry tipa - kak tip dannyh"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Обобщения (Generics)</span></h1><p>Из всего что стало и ещё станет известным о типизированном мире, тем кто только начинает свое знакомство с ним, тема посвященная обобщениям (<em>generics</em>) может представлятся наиболее сложной. Хотя данная тема, как и все остальные обладает некоторыми нюансами, каждый из которых будет детально разобран, в реальности рассматриваемые в ней механизмы очень просты и схватываются на лету. Поэтому приготовтесь что к концу главы место занимаемое множеством вопросов касающихся обобщений займет желание сделать все пользовательские конструкции универсальными. </p></section>\n<section class=\"content__section\" id=\"obobshcheniya_-_obshchie_ponyatiya\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"obobshcheniya - obshchie ponyatiya\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Обобщения - общие понятия</span></h2><p>Представьте огромный, дорогущий, высокотехнологичный типографский печатный станок выполенный в виде монолита что в свою очередь делает его пригодным для печати только одного номера газеты. То есть для печати сегодняшних новостей необходим один печатный станок, для завтрашних другой и т.д. Подобный станок сравним с <em>обычным типом</em> признаки которого после объявления остаются неизменны при его реализации. Другими словами если при существовании типа <code>A</code> описание которого включает поле принадлежащее к типу <code>number</code> потребуется тип отличие которого будет заключатся лишь в принадлежности поля, то возникнет необходимость в его объявлении. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// простые типы сравнимы с монолитами\n\n// этот станок предназначен для печати газет под номером A\ninterface A {\n    field: number;\n}\n\n// этот станок предназначен для печати газет под номером B\ninterface B {\n    field: string;\n}\n\n// и т.д.</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>К счастью в нашей реальности нашли решение не только относительно печатных станков, но и типов. Таким образом появилась парадигма <em>обобщенного программирования</em>.</p><p><em>Обобщенное программирование</em> (<em>Generic Programming</em>) — это подход, при котором алгоритмы могут одинаково работать с данными, принадлежащими к разным типам данных, без изменения декларации.</p><p>В основе обобщенного программирования лежит такое ключевое понятие как <em>обобщение</em>. <em>Обобщение</em> (<em>Generics</em>) - это <em>параметризированный тип</em> позволяющий объявлять <em>параметры типа</em> являющиеся временной заменой <em>конкретных типов</em> которые будут <em>конкретизированны</em> в момент создания экземпляра. Параметры типа можно использовать в большинстве операций допускающих работу с обычными типами. Все это вместе дает повод сравнивать обобщенный тип с <em>правильной версией</em>  печатного станка, чьи заменяемые валы предназначенные для отпечатывания информации на проходящей через них бумаге сопоставимы с <em>параметрами типа</em>.</p><p>В реальности обобщения позволяют сокращать количество преобразований (приведений) и писать многократно используемый код, при этом повышая его типобезопасность.</p><p>Этих примеров должно быть достаточно чтобы сложить отчетливый образ того чем на самом деле являются обобщения, но перед тем как продолжить стоит уточнить значения таких терминов как <em>обобщенный тип</em>, <em>параметризированный тип</em> и <em>универсальная конструкция</em> которые далеко не всем очевидны.</p><p>Для понимания этих терминов необходимо представить чертеж бумажного домика в который планируется поселить пойманного на пикнике жука. Когда гипотетический жук мысленно располагается вне границ начерченного жилища сопоставимого с типом, то оно предстает в виде <em>обобщенного типа</em>. Когда жук представляется внутри своей будущей обители, то о ней говорят как о <em>параметризированном типе</em>. Если же чертеж материализовался, хотя и в форму представленную обычной коробкой из под печенья, то её называют <em>универсальной конструкцией</em>. </p><p>Другими словами, тип определяющий параметр обозначается как обобщенный тип. при обсуждении типов представляемых параметрами типа необходимо уточнять что они определены в параметрезированном типе. Когда объявление обобщенного типа получило реализацию, то такую конструкцию, будь то класс или функция, называют универсальной (универсальный класс, универсальная функция или метод).</p></section>\n<section class=\"content__section\" id=\"obobshcheniya_v_typescript\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"obobshcheniya v typescript\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Обобщения в TypeScript</span></h2><p>В <em>TypeScript</em> обобщения могут быть указаны для типов, определяемых с помощью:</p><ul class=\"content__list\">\n<li><em>псевдонимов</em> (<code>type</code>)</li>\n<li><em>интерфейсов</em>, объявленных с помощью ключевого слова <code>interface</code></li>\n<li><em>классов</em> (<code>class</code>), в том числе <em>классовых выражений</em> (<em>class expression</em>)</li>\n<li><em>функций</em> (<code>function</code>) определенных в виде как деклараций (<em>Function Declaration</em>), так и выражений (<em>Function Expression</em>)</li>\n<li><em>методов</em> (<em>method</em>)</li>\n</ul><p>Обобщения объявляются при помощи пары угловых скобок, в которые через запятую, заключены <em>параметры типа</em> называемые также <em>типо-заполнителями</em> или <em>универсальными параметрами</em> <code>Type&#x3C;T0, T1></code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">        /**[0][1] [2] */\ninterface Type&lt;T0, T1&gt; {}\n\n/**\n * [0] объявление обобщенного типа Type\n * определяющего два параметра типа [1][2]\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Параметры типа могут быть указаны в качестве типа везде, где требуется аннотация типа, за исключением членов класса (static members). Область видимости параметров типа ограничена областью обобщенного типа. Все вхождения параметров типа будут заменены на конкретные типы, переданные в качестве аргументов типа. Аргументы типа указываются в угловых скобках, в которых через запятую указываются конкретные типы данных <code>Type&#x3C;number, string></code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">         /**[0]  [1]      [2] */\nlet value: Type&lt;number, string&gt;\n\n/**\n * [0] указание обобщенного типа\n * которому в качестве аргументов\n * указываются конкретные типы\n * number [1] и string [2]\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Идентификаторы параметров типа должны начинаться с заглавной буквы и кроме фантазии разработчика они также ограничены общими для <em>TypeScript</em> правилами. Если логическую принадлежность параметра типа возможно установить без какого-либо труда, как например в случае <code>Array&#x3C;T></code> кричащего что параметр типа <code>T</code> представляет тип к которым могут принадлежать элементы этого массива, то идентификаторы параметров типа принято выбирать из последовательности <code>T</code>, <code>S</code>, <code>U</code>, <code>V</code> и т.д. Также частая последовательность <code>T</code>, <code>U</code>, <code>V</code>, <code>S</code> и т.д.</p><p>С помощью <code>K</code> и <code>V</code> принято обозначать типы соответствующие <code>Key</code>/<code>Value</code>, а при помощи <code>P</code> — <code>Property</code>. Идентификатором <code>Z</code> принято обозначать полиморфный тип <code>this</code>.</p><p>Кроме того, не исключены случаи, в которых предпочтительнее выглядят полные имена, как например <code>RequestService</code>, <code>ResponseService</code>, к которым ещё можно применить <em>Венгерскую нотацию</em> - <code>TRequestService</code>, <code>TResponseService</code>.</p><p>К примеру, увидев в автодополнении редактора тип <code>Array&#x3C;T></code>, в голову сразу же приходит верный вариант, что массив будет содержать элементы принадлежащие к указанному типу <code>T</code>. Но, увидев <code>Animal&#x3C;T, S></code>, можно никогда не догадаться, что это типы данных, которые будут указаны для полей <code>id</code> и <code>arial</code>. В этом случае было бы гораздо предпочтительней дать говорящие имена <code>Animal&#x3C;AnimalID, AnimalArial></code> или даже <code>Animal&#x3C;TAnimalID, TAnimalArial></code> что позволит внутри тела параметрезированного типа <code>Animal</code> отличать его парамтры типа от конкретных объявлений.</p><p>Указывается обобщение сразу после идентификатора типа. Это правило остается неизменным даже в тех случаях, когда идентификатор отсутствует (как в случае с безымянным классовым или функциональным выражением), или же не предусмотрен вовсе (стрелочная функция).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">type Identifier&lt;T&gt; = {};\n\ninterface Identifier&lt;T&gt; {}\n\nclass Identifier&lt;T&gt; {\n    public identifier&lt;T&gt;(): void {}\n}\n\nlet identifier = class &lt;T&gt; {};\n\nfunction identifier&lt;T&gt;(): void {}\n\nlet identifier = function &lt;T&gt;(): void {};\n\nlet identifier = &lt;T&gt;() =&gt; {};</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Но, прежде чем приступить к детальному рассмотрению, нужно уточнить, что правила для функций идентичны, как для функциональных выражений, так и для методов. Правила для классов ничем не отличаются от правил для классовых выражений. Исходя из этого, все дальнейшие примеры будут приводиться исключительно на классах и функциях.</p><p>В случае, когда обобщение указанно псевдониму типа (<code>type</code>), область видимости параметров типа ограничена самим выражением. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">type T1&lt;T&gt; = { f1: T };</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Область видимости параметров типа при объявлении функции и функционального выражения, включая стрелочное, а также методов, ограничивается их сигнатурой и телом. Другими словами, параметр типа можно указывать в качестве типа при объявлении параметров, возвращаемого значения, а также в своем теле при объявлениях любых конструкций, требующих аннотацию типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">function f1&lt;T&gt;(p1: T): T {\n    let v1: T;\n    \n    return v1;\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>При объявлении классов (в том числе и классовых выражений) и интерфейсов, область видимости параметров типа ограничиваются областью объявления и телом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IT1&lt;T&gt; {\n    f1: T;\n}\n\nclass T1&lt;T&gt; {\n    public f1: T;\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В случаях, когда класс/интерфейс расширяет другой класс/интерфейс, который объявлен как обобщенный, потомок обязан указать типы для своего предка. Потомок в качестве аргумента типа своему предку может указать не только конкретный тип, но тип представляемый собственными параметрами типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IT1&lt;T&gt; {}\n\ninterface IT3&lt;T&gt; extends IT1&lt;T&gt; {}\ninterface IT2 extends IT1&lt;string&gt; {}\n\nclass T1&lt;T&gt; {}\n\nclass T2&lt;T&gt; extends T1&lt;T&gt; implements IT1&lt;T&gt; {}\nclass T3 extends T1&lt;string&gt; implements IT1&lt;string&gt; {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если класс/интерфейс объявлен как обобщенный, а внутри него объявлен обобщенный метод, имеющий идентичный параметр типа, то последний в свой области видимости будет перекрывать первый (более конкретно это поведение будет рассмотрено позднее).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IT1&lt;T&gt; {\n    m2&lt;T&gt;(p1: T): T;\n}\n\nclass T1&lt;T&gt; {\n    public m1&lt;T&gt;(p1: T): T {\n        let v1: T;\n        \n        return p1;\n    }\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Принадлежность параметра типа к конкретному типу данных устанавливается в момент передачи аргументов типа. При этом конкретные типы данных указываются в паре угловых скобок, а количество конкретных типов должно соответствовать количеству обязательных параметров типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal&lt;T&gt; {\n    constructor(readonly id: T) {}\n}\n\nvar bird: Animal&lt;string&gt; = new Animal(&#39;bird&#39;); // Ok\nvar bird: Animal&lt;string&gt; = new Animal(1); // Error\nvar fish: Animal&lt;number&gt; = new Animal(1); // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если обобщенный тип указывается в качестве типа данных, то он обязан содержать аннотацию обобщения (исключением является параметры типа по умолчанию, которые рассматриваются далее в главе).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal&lt;T&gt; {\n    constructor(readonly id: T) {}\n}\n\nvar bird: Animal = new Animal&lt;string&gt;(&#39;bird&#39;); // Error\nvar bird: Animal&lt;string&gt; = new Animal&lt;string&gt;(&#39;bird&#39;); // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Когда все обязательные параметры типа используются в параметрах конструктора, при создании экземпляра класса аннотацию обобщения можно опускать. В таком случае вывод типов определит принадлежность к типам по устанавливаемым значениям. Если же параметры являются необязательными, и значение не будет передано, то вывод типов определит принадлежность параметров типа к типу данных <code>unknown</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal&lt;T&gt; {\n    constructor(readonly id?: T) {}\n}\n  \nlet bird: Animal&lt;string&gt; = new Animal(&#39;bird&#39;); // Ok -&gt; bird: Animal&lt;string&gt;\nlet fish = new Animal(&#39;fish&#39;); // Ok -&gt; fish: Animal&lt;string&gt;\nlet insect = new Animal(); // Ok -&gt; insect: Animal&lt;unknown&gt;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Относительно обобщенных типов существуют такие понятия, как <em>открытый</em> (open) и <em>закрытый</em> (closed) тип. Обобщенный тип данных в момент определения называется <em>открытым</em>. Кроме того, типы, которые указаны в аннотации и у которых хотя бы один из аргументов типа является параметром типа, также являются открытыми типами. И наоборот, если все аргументы типа принадлежат к конкретным типам, то такой обобщенный тип является <em>закрытым</em> типом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class T0&lt;T, U&gt; {} //  T0 - открытый тип\n\nclass T1&lt;T&gt; {\n  public f: T0&lt;number, T&gt;; // T0 - открытый тип\n  public f1: T0&lt;number, string&gt;; // T0 - закрытый тип\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Те же самые правила применимы и к функциям, но за одним исключением — вывод типов для примитивных типов определяет принадлежность параметров типа к литеральным типам данных.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">function action&lt;T&gt;(value?: T): T | undefined {\n    return value;\n}\n  \naction&lt;number&gt;(0); // function action&lt;number&gt;(value?: number | undefined): number | undefined\naction(0); // function action&lt;0&gt;(value?: 0 | undefined): 0 | undefined\n\naction&lt;string&gt;(&#39;0&#39;); // function action&lt;string&gt;(value?: string | undefined): string | undefined\naction(&#39;0&#39;); // function action&lt;&quot;0&quot;&gt;(value?: &quot;0&quot; | undefined): &quot;0&quot; | undefined\n\naction(); // function action&lt;unknown&gt;(value?: unknown): unknown</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Тогда, когда параметры типа не участвуют в операциях при создании экземпляра класса и при этом аннотация обобщения не была указана явно, то вывод типа теряет возможность установить принадлежность к типу по значениям и поэтому устанавливает его принадлежность к типу <code>unknown</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal&lt;T&gt; {\n    public name: T;\n    \n    constructor(readonly id: string) {}\n}\n   \nlet bird: Animal&lt;string&gt; = new Animal(&#39;bird#1&#39;);\nbird.name = &#39;bird&#39;;\n// Ok -&gt; bird: Animal&lt;string&gt;\n// Ok -&gt; (property) Animal&lt;string&gt;.name: string\n\nlet fish = new Animal&lt;string&gt;(&#39;fish#1&#39;);\nfish.name = &#39;fish&#39;;\n// Ok -&gt; fish: Animal&lt;string&gt;\n// Ok -&gt; (property) Animal&lt;string&gt;.name: string\n\nlet insect = new Animal(&#39;insect#1&#39;);\ninsect.name = &#39;insect&#39;;\n// Ok -&gt; insect: Animal&lt;unknown&gt;\n// Ok -&gt; (property) Animal&lt;unknown&gt;.name: unknown</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>И опять, эти же правила верны и для функций.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">function action&lt;T&gt;(value?: T): T | undefined {\n    return value;\n}\n\naction&lt;string&gt;(&#39;0&#39;); // function action&lt;string&gt;(value?: string | undefined): string | undefined\naction(&#39;0&#39;); // function action&lt;&quot;0&quot;&gt;(value?: &quot;0&quot; | undefined): &quot;0&quot; | undefined\naction(); // function action&lt;unknown&gt;(value?: unknown): unknown</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В случаях, когда обобщенный класс содержит обобщенный метод, параметры типа метода будут затенять параметры типа класса.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">type ReturnParam&lt;T, U&gt; = { a: T, b: U };\n\nclass GenericClass&lt;T, U&gt; {\n    public defaultMethod&lt;T&gt; (a: T, b?: U): ReturnParam&lt;T, U&gt; {\n        return { a, b };\n    }\n    \n    public genericMethod&lt;T&gt; (a: T, b?: U): ReturnParam&lt;T, U&gt; {\n        return { a, b };\n    }\n}\n\nlet generic: GenericClass&lt;string, number&gt; = new GenericClass();\ngeneric.defaultMethod(&#39;0&#39;, 0);\ngeneric.genericMethod&lt;boolean&gt;(true, 0);\ngeneric.genericMethod(&#39;0&#39;);\n\n// Ok -&gt; generic: GenericClass&lt;string, number&gt;\n// Ok -&gt; (method) defaultMethod&lt;string&gt;(a: string, b?: number): ReturnParam&lt;string, number&gt;\n// Ok -&gt; (method) genericMethod&lt;boolean&gt;(a: boolean, b?: number): ReturnParam&lt;boolean, number&gt;\n// Ok -&gt; (method) genericMethod&lt;string&gt;(a: string, b?: number): ReturnParam&lt;string, number&gt;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Стоит заметить, что в <em>TypeScript</em>  нельзя создавать экземпляры типов, определенных параметрами типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface CustomConstructor&lt;T&gt; {\n    new(): T;\n}\n\nclass T1&lt;T extends CustomConstructor&lt;T&gt;&gt;{\n    public getInstance(): T {\n        return new T(); // Error\n    }\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Кроме того, два типа, определяемые классом или функцией, считаются идентичными, вне зависимости от того, являются они обобщенными или нет.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">type T1 = {}\ntype T1&lt;T&gt; = {} // Error -&gt; Duplicate identifier\n\nclass T2&lt;T&gt; {}\nclass T2 {} // Error -&gt; Duplicate identifier\n\nclass T3 {\n    public m1&lt;T&gt;(): void {}\n    public m1(): void {} // Error -&gt; Duplicate method\n}\n\nfunction f1&lt;T&gt;(): void {}\nfunction f1(): void {} // Error -&gt; Duplicate function</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"parametry_tipa_-_extends_(generic_constraints)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"parametry tipa - extends (generic constraints)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Параметры типа - extends (generic constraints)</span></h2><p>Помимо того, что параметры типа можно указывать в качестве конкретного типа данных, они также могут расширять другие типы данных, в том числе и другие параметры типа. Такой механизм требуется, когда значения внутри обобщенного типа должны обладать ограниченным набором признаков.</p><p>Ключевое слово <code>extends</code> размещается левее расширяемого типа и правее идентификатора параметра типа <code>&#x3C;T extends Type></code>. В качестве расширяемого типа может быть указан как конкретный тип данных, так и другой параметр типа. При чем в случае, когда один параметр типа расширяет другой, нет разницы в каком порядке они объявляются. Если параметр типа ограничен другим параметром типа, то такое ограничение называют <em>неприкрытым ограничением типа</em> (<em>naked type constraint</em>),</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class T1 &lt;T extends number&gt; {}\nclass T2 &lt;T extends number, U extends T&gt; {} // неприкрытое ограничение типа\nclass T3 &lt;U extends T, T extends number&gt; {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Механизм расширения требуется в тех случаях, при которых параметр типа должен обладать некоторыми характеристиками, требующимися для выполнения каких-либо операций над этим типом.</p><p>Для примера рассмотрим случай, когда в коллекции <code>T</code> (<code>Collection&#x3C;T></code>) объявлен метод получения элемента по имени (<code>getItemByName</code>).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Collection&lt;T&gt; {\n    private itemAll: T[] = [];\n    \n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    public getItemByName(name: string): T {\n        return this.itemAll.find(item =&gt; item.name === name); // Error -&gt; Property &#39;name&#39; does not exist on type &#39;T&#39;\n    }\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>При операции поиска в массиве возникнет ошибка. Ошибка возникнет потому, что в типе <code>T</code> не описано свойство <code>name</code>.</p><p>Для того чтобы ошибка исчезла, тип <code>T</code> должен расширить тип, в котором описано свойство <code>name</code>. В таком случае предпочтительней будет вариант объявления интерфейса <code>IName</code> с последующим его расширением.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IName {\n    name: string;\n}\n\nclass Collection&lt;T extends IName&gt; {\n    private itemAll: T[] = [];\n\n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    public getItemByName(name: string): T {\n        return this.itemAll.find(item =&gt; item.name === name); // Ok\n    }\n}\n\nabstract class Animal {\n    constructor(readonly name: string) {}\n}\n\nclass Bird extends Animal {}\nclass Fish extends Animal {}\n\nlet birdCollection: Collection&lt;Bird&gt; = new Collection();\nbirdCollection.add(new Bird(&#39;raven&#39;));\nbirdCollection.add(new Bird(&#39;owl&#39;));\n\nlet raven: Bird = birdCollection.getItemByName(&#39;raven&#39;); // Ok\n\nlet fishCollection: Collection&lt;Fish&gt; = new Collection();\nfishCollection.add(new Fish(&#39;shark&#39;));\nfishCollection.add(new Fish(&#39;barracuda&#39;));\n\nlet shark: Fish = fishCollection.getItemByName(&#39;shark&#39;); // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Пример, когда параметр типа расширяет другой параметр типа, будет рассмотрен немного позднее.</p><p>Также не лишним будет заметить, что когда параметр типа расширяет другой тип, то в качестве аргумента типа можно будет передать только совместимый с ним тип.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface Bird { fly(): void; }\ninterface Fish { swim(): void; }\n\ninterface IEgg&lt;T extends Bird&gt; { child: T; }\n\nlet v1: IEgg&lt;Bird&gt;; // Ok\nlet v2: IEgg&lt;Fish&gt;; // Error -&gt; Type &#39;Fish&#39; does not satisfy the constraint &#39;Bird&#39;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Кроме того, расширять можно любые предназначенные для расширения типы, полученные любым доступным путем.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    name: string;\n    age: number;\n}\n\nlet animal: IAnimal;\n\nclass Bird&lt;T extends typeof animal&gt; {} // T extends IAnimal\nclass Fish&lt;K extends keyof IAnimal&gt; {} // K extends &quot;name&quot; | &quot;age&quot;\nclass Insect&lt;V extends IAnimal[K], K extends keyof IAnimal&gt; {} // V extends string | number\nclass Reptile&lt;T extends number | string, U extends number &amp; string&gt; {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Помимо прочего одна важная и не очевидная особенность связанна с расширение параметром типа типа <code>any</code>. Может показаться что в таком случае над параметром типа будет возможно производить любые допустимые типом <code>any</code> операции. Но поскольку <code>any</code> допускает совершать над собой любые операции, то для повышения типобезопасности подобное поведение было отмененно для типов представляемых параметрами типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\"> class ClassType&lt;T extends any&gt; {\n     private f0: any = {}; // Ok\n     private field: T = {}; // Error [0]\n\n     constructor(){\n         this.f0.notExistsMethod(); // Ok [1]\n         this.field.notExistsMethod(); // Error [2]\n     }\n }\n\n /**\n  * Поскольку параметр типа расширяющий тип any\n  * подрывает типобезолпасность программы, то вывод\n  * типов такой параметр расценивает как принадлежащий\n  * к типу unknown запрещающий любые операции над собой.\n  * \n  * [0] тип unknown не совместим с объектным типом {}.\n  * [1] Ok на этапе компиляции и Error вов ремя выполнения.\n  * [2] тип unknown не описывает метода notExistsMethod().\n  */ </code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"parametra_tipa_-_znachenie_po_umolchaniu_=_(generic_parameter_defaults)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"parametra tipa - znachenie po umolchaniu = (generic parameter defaults)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Параметра типа - значение по умолчанию = (generic parameter defaults)</span></h2><p>Помимо прочего <em>TypeScript</em> позволяет указывать для параметров типа значение по умолчанию.</p><p>Значение по умолчанию указывается с помощью оператора равно <code>=</code>, слева от которого располагается параметр типа, а справа конкретный тип, либо другой параметр типа <code>T = Type</code>. Параметры, которым заданы значения по умолчанию, являются необязательными параметрами. Необязательные параметры типа должны быть перечислены строго после обязательных. Если параметр типа указывается в качестве типа по умолчанию, то ему самому должно быть задано значение по умолчанию, либо он должен расширять другой тип. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class T1&lt;T = string&gt; {} // Ok\nclass T2&lt;T = U, U&gt; {} // Error -&gt; необязательное перед обязательным\nclass T3&lt;T = U, U  = number&gt; {} // Ok\n\nclass T4&lt;T = U, U extends number&gt; {} // Error -&gt; необязательное перед обязательным\nclass T5&lt;U extends number, T = U&gt; {} // Ok.</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Кроме того, можно совмещать механизм установки значения по умолчанию и механизм расширения типа. В этом случае оператор равно <code>=</code> указывается после расширяемого типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class T1 &lt;T extends T2 = T3&gt; {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В момент, когда тип <code>T</code> расширяет другой тип, он получает признаки этого типа. Именно поэтому для параметра типа, расширяющего другой тип, в качестве типа по умолчанию можно указывать только совместимый с ним тип. </p><p>Чтобы было проще понять, нужно представить два класса, один из которых расширяет другой. В этом случае переменной с типом суперкласса можно в качестве значения присвоить объект его подкласса, но — не наоборот.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal {\n    public name: string;\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nlet bird: Animal = new Bird(); // Ok\nlet animal: Bird = new Animal(); // Error</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Тот же самый механизм используется для параметров типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal {\n    public name: string;\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nclass T1 &lt;T extends Animal = Bird&gt; {} // Ok\n// -------(   Animal   ) = Bird\n\nclass T2 &lt;T extends Bird = Animal&gt; {} // Error\n// -------(   Bird   ) = Animal</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Необходимо сделать акцент на том, что вывод типов обращает внимание только при работе с аргументами типа. Чтобы было более понятно вспомним ещё раз что механизм ограничения парамтров типа с помощью ключевого слова <code>extends</code> наделяет их указанными признаками служащими не только для ограничения аругментов типа, но и для выполнения опреаций в области видимости. Другими словами вывод типов при работе с аргументами типа берет во внимание как ограничивающий тип, так и тип указанный в качестве типа по умолчанию.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// ограничение типа T типом string\ndeclare class A&lt;T extends string&gt;{\n    constructor(value?: T)\n}\n\n// тип string устанавливается типу T в качестве типа по умолчанию\ndeclare class B&lt;T = string&gt;{\n    constructor(value?: T)\n}\n\n\n/**[0] */\nlet a0 = new A(); // Ok\nlet a1 = new A(`ts`); // Ok \nlet a2 = new A(0); // Error -&gt;  Argument of type &#39;0&#39; is not assignable to parameter of type &#39;string | undefined&#39;.\n\n/**[1] */\nlet b0 = new B(); // Ok\nlet b1 = new B(`ts`); // Ok \nlet b2 = new B(0); // Ok\n\n/**\n * Вывод типов беретпри работе с аргументами типа\n * берет во внимание как тип расширяющий его [0]\n * так и тип указанный в качестве значения по умолчанию [1].\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Но при работе со значениями принадлежащих к типу <code>T</code> вывод типов берет в расчет только ограничивающий тип, но не тип выступающий в качестве типа по умолчанию.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// ограничение типа T типом string\nclass A&lt;T extends string&gt;{\n    constructor(value?: T){\n        value?.toLowerCase(); // Ok /**[0] */\n    }\n}\n\n// тип string устанавливается типу T в качестве типа по умолчанию\nclass B&lt;T = string&gt;{\n    constructor(value?: T) {\n        value?.toLowerCase(); // Error /**[1] */\n    }\n}\n\n/**\n * Вы вод типов берет в расчет только ограничивающий тип [0]\n * но не тип указанный в качестве типа по умолчанию [1].\n * \n * [0] value наделено признаками типа T.\n * [1] у value отсутствуют какие-либо признаки.  \n * \n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Не будет лишним также рассмотреть отличия этих двух механизмов при работе вывода типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// ограничение типа T типом string\ndeclare class A&lt;T extends string&gt;{\n    constructor(value?: T)\n}\n\n// тип string устанавливается типу T в качестве типа по умолчанию\ndeclare class B&lt;T = string&gt;{\n    constructor(value?: T)\n}\n\n\nlet a0 = new A(); // Ok -&gt; let a0: A&lt;string&gt;\nlet b0 = new B(); // Ok -&gt; let b0: B&lt;string&gt;\n\nlet a1 = new A(`ts`); // Ok -&gt; let a1: A&lt;&quot;ts&quot;&gt;\nlet b1 = new B(`ts`); // Ok -&gt; let b1: B&lt;string&gt;\n\nlet a2 = new A&lt;string&gt;(`ts`); // Ok -&gt; let a2: A&lt;string&gt;\nlet b2 = new B&lt;string&gt;(`ts`); // Ok -&gt; let b2: B&lt;string&gt;\n\nlet a3 = new A&lt;number&gt;(0); // Error\nlet b3 = new B&lt;number&gt;(0); // Ok -&gt; let b3: B&lt;number&gt;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"parametry_tipa_-_kak_tip_dannyh\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"parametry tipa - kak tip dannyh\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Параметры типа - как тип данных</span></h2><p>Параметры типа, указанные в угловых скобках при объявлении обобщенного типа, изначально не принадлежат ни к одному типу данных. Несмотря на это, компилятор расценивает параметры типа, как совместимые с такими типами как <code>any</code> и <code>never</code> и самим собой.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">function f0&lt;T&gt;(p: any): T { // Ok, any совместим с T\n    return p;\n}\n\nfunction f1&lt;T&gt;(p: never): T { // Ok, never совместим с T\n    return p;\n}\n\nfunction f2&lt;T&gt;(p: T): T { // Ok, T совместим с T\n    return p;\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если обобщенная коллекция, в качестве аргумента типа, получает тип данных объединение (<code>Union</code>), то все её элементы будут принадлежать к типу объединения. Простыми словами, элемент из такой коллекции не будет, без явного преобразования, совместим ни с одним из вариантов, составляющих тип объединение.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IName { name: string; }\n\ninterface IAnimal extends IName {}\n\nabstract class Animal implements IAnimal {\n  constructor(readonly name: string) {}\n}\n\nclass Bird extends Animal {\n    public fly(): void {}\n}\n\nclass Fish extends Animal {\n    public swim(): void {}\n}\n\nclass Collection&lt;T extends IName&gt; {\n    private itemAll: T[] = [];\n    \n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    public getItemByName(name: string): T {\n        return this.itemAll.find(item =&gt; item.name === name); // Ok\n    }\n}\n\nlet collection: Collection&lt;Bird | Fish&gt; = new Collection();\n  collection.add(new Bird(&#39;bird&#39;));\n  collection.add(new Fish(&#39;fish&#39;));\n\nvar bird: Bird = collection.getItemByName(&#39;bird&#39;); // Error -&gt; Type &#39;Bird | Fish&#39; is not assignable to type &#39;Bird&#39;\nvar bird: Bird = collection.getItemByName(&#39;bird&#39;) as Bird; // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Но операцию приведения типов можно поместить (сокрыть) прямо в метод самой коллекции и тем самым упростить её использование. Для этого метод должен быть обобщенным, а его параметр типа, указанный в качестве возвращаемого из функции типа, расширять параметр типа самой коллекции. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// ...\n\nclass Collection&lt;T extends IName&gt; {\n    private itemAll: T[] = [];\n    \n    public add(item: T): void {\n        this.itemAll.push(item);\n    }\n\n    // 1. параметр типа U должен расширять параметр типа T\n    // 2. возвращаемый тип указан как U\n    // 3. возвращаемое значение нуждается в явном преобразовании к типу U\n    public getItemByName&lt;U extends T&gt;(name: string): U {\n        return this.itemAll.find(item =&gt; item.name === name) as U; // Ok\n    }\n}\n\nlet collection: Collection&lt;Bird | Fish&gt; = new Collection();\n collection.add(new Bird(&#39;bird&#39;));\n collection.add(new Fish(&#39;fish&#39;));\n\nvar bird: Bird = collection.getItemByName(&#39;bird&#39;); // Ok\nvar birdOrFish = collection.getItemByName(&#39;bird&#39;); // Bad, var birdOrFish: Bird | Fish\nvar bird = collection.getItemByName&lt;Bird&gt;(&#39;bird&#39;); // Ok, var bird: Bird</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Сокрытие приведения типов прямо в методе коллекции повысило “привлекательность” кода. Но, все же, в случаях, когда элемент коллекции присваивается конструкции без явной аннотации типа, появляется потребность вызывать обобщенный метод с аргументами типа.</p><p>Кроме того, нужно не забывать, что два разных объявления параметров типа несовместимы, даже если у них идентичные идентификаторы.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Identifier&lt;T&gt; {\n    array: T[] = [];\n    \n    method&lt;T&gt;(param: T): void  {\n        this.array.push(param); // Error, T объявленный в сигнатуре функции не совместим с типом T объявленном в сигнатуре класса\n    }\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>","commitInfoAll":[{"committedDate":"2020-09-08T11:53:53Z","message":"book(технические изменения (link, md, т.п.)): change code wrapper\n\nchange code wrapper from ~ to ` and from typescript to ts","messageHeadline":"book(технические изменения (link, md, т.п.)): change code wrapper","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars3.githubusercontent.com/u/31518738?v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/032\\.\\(Типы\\) Обобщения \\(Generics\\)/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"chto takoe i dlya chego nujen typescript","sections":[{"name":"Что такое TypeScript","path":"chto takoe typescript"},{"name":"История TypeScript","path":"istoriya typescript"},{"name":"Для чего нужен TypeScript","path":"dlya chego nujen typescript"},{"name":"Зачем разработчику TypeScript","path":"zachem razrabotchiku typescript"}]},{"name":"Вступление","path":"vstuplenie","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"sistema tipov, tip dannyh, znachimye i ssylochnye tipy","sections":[{"name":"Система Типов","path":"sistema tipov"},{"name":"Тип данных (тип)","path":"tip dannyh (tip)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"tip dannyh, peredaushchiisya po znacheniu (primitivnyi tip)"},{"name":"Тип данных, передающийся по ссылке","path":"tip dannyh, peredaushchiisya po ssylke"}]},{"name":"Связывание, типизация, вывод типов","path":"svyazyvanie, tipizaciya, vyvod tipov","sections":[{"name":"Обработка кода компилятором","path":"obrabotka koda kompilyatorom"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"leksicheskii analiz (tokenizaciya - tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"sintaksicheskii analiz (razbor - parsing)"},{"name":"Семантический анализ","path":"semanticheskii analiz"},{"name":"Связывание (Binding)","path":"svyazyvanie (binding)"},{"name":"Типизация","path":"tipizaciya"},{"name":"Вывод Типов (type inference)","path":"vyvod tipov (type inference)"}]},{"name":"Преобразование типов","path":"preobrazovanie tipov","sections":[{"name":"Неявные Преобразования","path":"neyavnye preobrazovaniya"},{"name":"Явные Преобразования","path":"yavnye preobrazovaniya"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"tipizirovannye i netipizirovannye yazyki programmirovaniya","sections":[{"name":"Нетипизированные языки","path":"netipizirovannye yazyki"},{"name":"Типизированные языки","path":"tipizirovannye yazyki"}]},{"name":"Статическая и динамическая типизация","path":"staticheskaya i dinamicheskaya tipizaciya","sections":[{"name":"Статическая типизация (Static Typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"dinamicheskaya tipizaciya (dynamic typing)"}]},{"name":"Сильная и слабая типизация","path":"silnaya i slabaya tipizaciya","sections":[{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Слабая типизация (weakly typed)","path":"slabaya tipizaciya (weakly typed)"}]},{"name":"Явная и неявная типизация","path":"yavnaya i neyavnaya tipizaciya","sections":[{"name":"Явная типизация (explicit typing)","path":"yavnaya tipizaciya (explicit typing)"},{"name":"Неявная типизация (implicit typing)","path":"neyavnaya tipizaciya (implicit typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"sovmestimost tipov na osnove vida tipizacii","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"sovmestimost tipov (types compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"nominativnaya tipizaciya (nominative typing)"},{"name":"Структурная Типизация (structural typing)","path":"strukturnaya tipizaciya (structural typing)"},{"name":"Утиная Типизация (Duck typing)","path":"utinaya tipizaciya (duck typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"sovmestimost tipov na osnove variantnosti","sections":[{"name":"Вариантность","path":"variantnost"},{"name":"Иерархия наследования","path":"ierarhiya nasledovaniya"},{"name":"Ковариантность","path":"kovariantnost"},{"name":"Контравариантность","path":"kontravariantnost"},{"name":"Инвариантность","path":"invariantnost"},{"name":"Бивариантность","path":"bivariantnost"}]},{"name":"Аннотация Типов","path":"annotaciya tipov","sections":[{"name":"Аннотация Типов - общее","path":"annotaciya tipov - obshchee"},{"name":"Аннотация типа","path":"annotaciya tipa"},{"name":"Синтаксические конструкции var, let, const","path":"sintaksicheskie konstrukcii var, let, const"},{"name":"Функции (function)","path":"funkcii (function)"},{"name":"Стрелочные Функции (arrow function)","path":"strelochnye funkcii (arrow function)"},{"name":"Классы (class)","path":"klassy (class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"sravnenie sintaksisa typescript i javascript"},{"name":"Итог","path":"itog"}]},{"name":"Базовый Тип Any","path":"bazovyi tip any","sections":[{"name":"Any (any) произвольный тип","path":"any (any) proizvolnyi tip"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"primitivnye tipy number, string, boolean, symbol, bigint","sections":[{"name":"Важно","path":"vajno"},{"name":"Number (number) примитивный числовой тип","path":"number (number) primitivnyi chislovoi tip"},{"name":"String (string) примитивный строковый тип","path":"string (string) primitivnyi strokovyi tip"},{"name":"Boolean (boolean) примитивный логический тип","path":"boolean (boolean) primitivnyi logicheskii tip"},{"name":"Symbol (symbol) примитивный символьный тип","path":"symbol (symbol) primitivnyi simvolnyi tip"},{"name":"BigInt (bigint) примитивный числовой тип","path":"bigint (bigint) primitivnyi chislovoi tip"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"primitivnye tipy null, undefined, void, never, unknown","sections":[{"name":"Важно","path":"vajno"},{"name":"Null (null) примитивный null тип","path":"null (null) primitivnyi null tip"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"undefined (undefined) primitivnyi neopredelennyi tip"},{"name":"Void (void) отсутствие конкретного типа","path":"void (void) otsutstvie konkretnogo tipa"},{"name":"Never (never) примитивный тип","path":"never (never) primitivnyi tip"},{"name":"Unknown (unknown)","path":"unknown (unknown)"}]},{"name":"Примитивный Тип Enum","path":"primitivnyi tip enum","sections":[{"name":"Enum (enum) примитивный перечисляемый тип","path":"enum (enum) primitivnyi perechislyaemyi tip"},{"name":"Перечисления с числовым значением","path":"perechisleniya s chislovym znacheniem"},{"name":"Перечисления со строковым значением","path":"perechisleniya so strokovym znacheniem"},{"name":"Смешанное перечисление (mixed enum)","path":"smeshannoe perechislenie (mixed enum)"},{"name":"Перечисление в качестве типа данных","path":"perechislenie v kachestve tipa dannyh"},{"name":"Перечисление const с числовым и строковым значением","path":"perechislenie const s chislovym i strokovym znacheniem"},{"name":"Когда стоит применять enum?","path":"kogda stoit primenyat enum?"}]},{"name":"Типы - Union, Intersection","path":"tipy - union, intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"tip obedinenie (union types)"},{"name":"Тип Пересечение (Intersection Type)","path":"tip peresechenie (intersection type)"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"type queries (zaprosy tipa), alias (psevdonimy tipa)","sections":[{"name":"Запросы Типа (Type Queries)","path":"zaprosy tipa (type queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"psevdonimy tipov (type aliases)"}]},{"name":"Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum","path":"primitivnye literalnye tipy number, string, boolean, unique symbol, enum","sections":[{"name":"Литеральный тип Number (Numeric Literal Types)","path":"literalnyi tip number (numeric literal types)"},{"name":"Литеральный тип String (String Literal Types)","path":"literalnyi tip string (string literal types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"literalnyi tip boolean (boolean literal types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"literalnyi tip unique symbol (unique symbol) unikalnyi simvolnyi tip"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"literalnyi tip enum (enum literal types)"}]},{"name":"Object, Array, Tuple","path":"object, array, tuple","sections":[{"name":"Object (object) — ссылочный объектный тип","path":"object (object) — ssylochnyi obektnyi tip"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"array (type[]) ssylochnyi massivopodobnyi tip"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"tuple ([t0, t1, …, tn]) tip kortej"}]},{"name":"Function, Functional Types","path":"function, functional types","sections":[{"name":"Function Types - тип функция","path":"function types - tip funkciya"},{"name":"Functional Types - функциональный тип","path":"functional types - funkcionalnyi tip"},{"name":"this в сигнатуре функции","path":"this v signature funkcii"}]},{"name":"Interfaces","path":"interfaces","sections":[{"name":"Общая теория","path":"obshchaya teoriya"},{"name":"Интерфейс в TypeScript","path":"interfeis v typescript"},{"name":"Объявление (declaration)","path":"obyavlenie (declaration)"},{"name":"Конвенции именования интерфейсов","path":"konvencii imenovaniya interfeisov"},{"name":"Реализация интерфейса (implements)","path":"realizaciya interfeisa (implements)"},{"name":"Декларация свойств get и set (accessors)","path":"deklaraciya svoistv get i set (accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"ukazanie interfeisa v kachestve tipa (interface types)"},{"name":"Расширение интерфейсов (extends interface)","path":"rasshirenie interfeisov (extends interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"rasshirenie interfeisom klassa (extends class)"},{"name":"Описание класса (функции-конструктора)","path":"opisanie klassa (funkcii-konstruktora)"},{"name":"Описание функционального выражения","path":"opisanie funkcionalnogo vyrajeniya"},{"name":"Описание индексных членов в объектных типов","path":"opisanie indeksnyh chlenov v obektnyh tipov"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"inlain interfeisy (inline interface)"},{"name":"Слияние интерфейсов","path":"sliyanie interfeisov"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)","sections":[{"name":"Типы — Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"tipy — obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)","sections":[{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)"},{"name":"Модификатор доступа public (публичный)","path":"modifikator dostupa public (publichnyi)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"modifikator dostupa private (zakrytyi ili skrytyi)"},{"name":"Модификатор доступа protected (защищенный)","path":"modifikator dostupa protected (zashchishchennyi)"},{"name":"Модификаторы доступа и конструкторы класса","path":"modifikatory dostupa i konstruktory klassa"},{"name":"Быстрое объявление полей","path":"bystroe obyavlenie polei"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript","sections":[{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript"}]},{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)","sections":[{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)"},{"name":"Общие характеристики","path":"obshchie harakteristiki"},{"name":"Теория","path":"teoriya"}]},{"name":"Полиморфный тип this","path":"polimorfnyi tip this","sections":[{"name":"Полиморфный тип this","path":"polimorfnyi tip this"}]},{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)","sections":[{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)"}]},{"name":"Definite Assignment Assertion Modifier","path":"definite assignment assertion modifier","sections":[{"name":"Классы — Definite Assignment Assertion Modifier","path":"klassy — definite assignment assertion modifier"}]},{"name":"Классы — Тонкости","path":"klassy — tonkosti","sections":[{"name":"Классы — Тонкости","path":"klassy — tonkosti"},{"name":"Классы - Тонкости implements","path":"klassy - tonkosti implements"},{"name":"Частичное Слияние интерфейса с классом","path":"chastichnoe sliyanie interfeisa s klassom"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"pereopredelenie svoistv polyami i naoborot pri nasledovanii"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov","sections":[{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov"},{"name":"Итог","path":"itog"}]},{"name":"Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"optional, not-null, not-undefined, definite assignment assertion","sections":[{"name":"Операторы — Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"operatory — optional, not-null, not-undefined, definite assignment assertion"},{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"neobyazatelnye polya, parametry i metody (optional fields, parameters and methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"operator ! (non-null and non-undefined operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"operator ! (definite assignment assertion)"},{"name":"Итог","path":"itog"}]},{"name":"Обобщения (Generics)","path":"obobshcheniya (generics)","sections":[{"name":"Обобщения - общие понятия","path":"obobshcheniya - obshchie ponyatiya"},{"name":"Обобщения в TypeScript","path":"obobshcheniya v typescript"},{"name":"Параметры типа - extends (generic constraints)","path":"parametry tipa - extends (generic constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"parametra tipa - znachenie po umolchaniu = (generic parameter defaults)"},{"name":"Параметры типа - как тип данных","path":"parametry tipa - kak tip dannyh"}]},{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)","sections":[{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)"}]},{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa","sections":[{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa"}]},{"name":"Утверждение Типов (Type Assertion)","path":"utverjdenie tipov (type assertion)","sections":[{"name":"Утверждение Типов - общее","path":"utverjdenie tipov - obshchee"},{"name":"Утверждение Типа `<Type>` синтаксис","path":"utverjdenie tipa `<type>` sintaksis"},{"name":"Утверждение Типа с помощью оператора as","path":"utverjdenie tipa s pomoshchu operatora as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"privedenie (utverjdenie) k konstante (const assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"utverjdenie v signature (signature assertion)"},{"name":"Итоги","path":"itogi"}]},{"name":"Защитники типа","path":"zashchitniki tipa","sections":[{"name":"Защитники Типа - общее","path":"zashchitniki tipa - obshchee"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"sujenie diapazona mnojestva tipov na osnove tipa dannyh"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"sujenie diapazona mnojestva tipov na osnove priznakov prisushchih tipu tagged union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"sujenie diapazona mnojestva tipov na osnove dostupnyh chlenov obekta"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"sujenie diapazona mnojestva tipov na osnove funkcii, opredelennoi polzovatelem"}]},{"name":"Вывод типов","path":"vyvod tipov","sections":[{"name":"Вывод типов - общие сведения","path":"vyvod tipov - obshchie svedeniya"},{"name":"Вывод примитивных типов","path":"vyvod primitivnyh tipov"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"vyvod primitivnyh tipov dlya konstant (const) i polei tolko dlya chteniya (readonly)"},{"name":"Вывод объектных типов","path":"vyvod obektnyh tipov"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"vyvod tipa dlya polei klassa na osnove inicializacii ih v konstruktore"},{"name":"Вывод объединенных (Union) типов","path":"vyvod obedinennyh (union) tipov"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"vyvod peresecheniya (intersection) s diskriminantnymi polyami"},{"name":"Вывод типов кортеж (Tuple)","path":"vyvod tipov kortej (tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"sovmestimost obektnyh tipov (compatible object types)","sections":[{"name":"Важно","path":"vajno"},{"name":"Совместимость объектных типов в TypeScript","path":"sovmestimost obektnyh tipov v typescript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"sovmestimost funkcionalnyh tipov (compatible function types)","sections":[{"name":"важно","path":"vajno"},{"name":"Совместимость параметров","path":"sovmestimost parametrov"},{"name":"Совместимость возвращаемого значения","path":"sovmestimost vozvrashchaemogo znacheniya"}]},{"name":"Совместимость объединений (Union Types)","path":"sovmestimost obedinenii (union types)","sections":[{"name":"Совместимость","path":"sovmestimost"}]},{"name":"Типизация в TypeScript","path":"tipizaciya v typescript","sections":[{"name":"Общие сведения","path":"obshchie svedeniya"},{"name":"Статическая типизация (static typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)"},{"name":"Вариантность (variance)","path":"variantnost (variance)"},{"name":"Наилучший общий тип (Best common type)","path":"nailuchshii obshchii tip (best common type)"},{"name":"Контекстный тип (Contextual Type)","path":"kontekstnyi tip (contextual type)"},{"name":"Итог","path":"itog"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -","sections":[{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -"},{"name":"Запрос ключей keyof","path":"zapros kluchei keyof"},{"name":"Поиск типов (Lookup Types)","path":"poisk tipov (lookup types)"},{"name":"Сопоставление типов (Mapped Types)","path":"sopostavlenie tipov (mapped types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"prefiksy + i - v sopostavlennyh tipah"}]},{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)","sections":[{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"raspredelitelnye uslovnye tipy (distributive conditional types)"},{"name":"Вывод типов в условном типе","path":"vyvod tipov v uslovnom tipe"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"readonly, partial, required, pick, record","sections":[{"name":"Расширенные типы — Readonly, Partial, Required, Pick, Record","path":"rasshirennye tipy — readonly, partial, required, pick, record"},{"name":"Readonly","path":"readonly"},{"name":"Partial","path":"partial"},{"name":"Required","path":"required"},{"name":"Pick","path":"pick"},{"name":"Record","path":"record"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"exclude, extract, nonnullable, returntype, instancetype, omit","sections":[{"name":"Расширенные типы — Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"rasshirennye tipy — exclude, extract, nonnullable, returntype, instancetype, omit"},{"name":"Exclude","path":"exclude"},{"name":"Extract","path":"extract"},{"name":"NonNullable","path":"nonnullable"},{"name":"ReturnType","path":"returntype"},{"name":"InstanceType","path":"instancetype"},{"name":"Parameters","path":"parameters"},{"name":"ConstructorParameters","path":"constructorparameters"},{"name":"Тип Omit","path":"tip omit"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"massivopodobnye readonly tipy, readonlyarray, readonlymap, readonlyset","sections":[{"name":"Массивоподобные readonly типы","path":"massivopodobnye readonly tipy"},{"name":"ReadonlyArray","path":"readonlyarray"},{"name":"ReadonlyMap","path":"readonlymap"},{"name":"ReadonlySet","path":"readonlyset"}]},{"name":"Синтаксические конструкции и операторы","path":"sintaksicheskie konstrukcii i operatory","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"operatory prisvaivaniya korotkogo zamykaniya (&&=, ||=, &&=)"},{"name":"Операнды для delete должны быть необязательными","path":"operandy dlya delete doljny byt neobyazatelnymi"}]},{"name":"React - расширение .tsx","path":"react - rasshirenie .tsx","sections":[{"name":"React — расширение .tsx","path":"react — rasshirenie .tsx"}]},{"name":"Функциональные компоненты","path":"funkcionalnye komponenty","sections":[{"name":"Определение компонента как Function Declaration","path":"opredelenie komponenta kak function declaration"},{"name":"Определение компонента как Function Expression","path":"opredelenie komponenta kak function expression"}]},{"name":"Классовые компоненты","path":"klassovye komponenty","sections":[{"name":"React — производные от Component","path":"react — proizvodnye ot component"},{"name":"React - производные от PureComponent","path":"react - proizvodnye ot purecomponent"}]},{"name":"Универсальные компоненты","path":"universalnye komponenty","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"obobshchennye komponenty (generics component)"}]},{"name":"Типизированные хуки","path":"tipizirovannye huki","sections":[{"name":"Предопределенные хуки","path":"predopredelennye huki"},{"name":"Пользовательский хук","path":"polzovatelskii huk"}]},{"name":"Контекст (Context)","path":"kontekst (context)","sections":[{"name":"Определение контекста","path":"opredelenie konteksta"}]},{"name":"HOC (Higher-Order Components)","path":"hoc (higher-order components)","sections":[{"name":"Определение hoc","path":"opredelenie hoc"},{"name":"Определение hoc на основе функционального компонента","path":"opredelenie hoc na osnove funkcionalnogo komponenta"},{"name":"Определение hoc на основе классового компонента","path":"opredelenie hoc na osnove klassovogo komponenta"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"prostranstva imen (namespace) i moduli (module)","sections":[{"name":"Namespace и module — предназначение","path":"namespace i module — prednaznachenie"},{"name":"Namespace - определение","path":"namespace - opredelenie"},{"name":"Модули (export, import) — определение","path":"moduli (export, import) — opredelenie"},{"name":"Конфигурирование проекта","path":"konfigurirovanie proekta"}]},{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya","sections":[{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"sborka proekta s pomoshchu tsc (typescript compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"sborka s ispolzovaniem ssylok na proekty","sections":[{"name":"Ссылки на проекты","path":"ssylki na proekty"}]},{"name":"Декларации","path":"deklaracii","sections":[{"name":"Что такое декларация (Declaration)","path":"chto takoe deklaraciya (declaration)"},{"name":"Установка деклараций с помощью @types","path":"ustanovka deklaracii s pomoshchu @types"},{"name":"Подготовка к созданию декларации","path":"podgotovka k sozdaniu deklaracii"},{"name":"Разновидности деклараций","path":"raznovidnosti deklaracii"},{"name":"Декларации и область видимости","path":"deklaracii i oblast vidimosti"},{"name":"Декларации для библиотек с одной точкой входа","path":"deklaracii dlya bibliotek s odnoi tochkoi vhoda"},{"name":"Декларации для библиотек с множеством точек входа","path":"deklaracii dlya bibliotek s mnojestvom tochek vhoda"},{"name":"Создание деклараций вручную","path":"sozdanie deklaracii vruchnuu"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"direktiva s troinym sleshem (triple-slash directives)"},{"name":"Импортирование декларации (import)","path":"importirovanie deklaracii (import)"}]},{"name":"Публикация","path":"publikaciya","sections":[{"name":"Публикация","path":"publikaciya"}]},{"name":"Опции компилятора","path":"opcii kompilyatora","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressexcesspropertyerrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressimplicitanyindexerrors"},{"name":"noImplicitAny","path":"noimplicitany"},{"name":"checkJs","path":"checkjs"},{"name":"JSX","path":"jsx"},{"name":"jsxFactory","path":"jsxfactory"},{"name":"target (t)","path":"target (t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysstrict"},{"name":"strictNullChecks","path":"strictnullchecks"},{"name":"stripInternal","path":"stripinternal"},{"name":"noImplicitThis","path":"noimplicitthis"},{"name":"noImplicitUseStrict","path":"noimplicitusestrict"},{"name":"baseUrl","path":"baseurl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootdir"},{"name":"rootDirs","path":"rootdirs"},{"name":"traceResolution","path":"traceresolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"nolib"},{"name":"noResolve","path":"noresolve"},{"name":"noStrictGenericChecks","path":"nostrictgenericchecks"},{"name":"preserveConstEnums","path":"preserveconstenums"},{"name":"removeComments","path":"removecomments"},{"name":"noUnusedLocals","path":"nounusedlocals"},{"name":"noUnusedParameters","path":"nounusedparameters"},{"name":"skipLibCheck","path":"skiplibcheck"},{"name":"declarationDir","path":"declarationdir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeroots"},{"name":"allowUnusedLabels","path":"allowunusedlabels"},{"name":"noImplicitReturns","path":"noimplicitreturns"},{"name":"noFallthroughCasesInSwitch","path":"nofallthroughcasesinswitch"},{"name":"outFile","path":"outfile"},{"name":"allowSyntheticDefaultImports","path":"allowsyntheticdefaultimports"},{"name":"allowUnreachableCode","path":"allowunreachablecode"},{"name":"allowJs","path":"allowjs"},{"name":"reactNamespace","path":"reactnamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleresolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noemithelpers"},{"name":"newLine","path":"newline"},{"name":"inlineSourceMap","path":"inlinesourcemap"},{"name":"inlineSources","path":"inlinesources"},{"name":"noEmitOnError","path":"noemitonerror"},{"name":"noEmit","path":"noemit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downleveliteration"},{"name":"emitBOM","path":"emitbom"},{"name":"emitDecoratorMetadata","path":"emitdecoratormetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceconsistentcasinginfilenames"},{"name":"help (h)","path":"help (h)"},{"name":"importHelpers","path":"importhelpers"},{"name":"isolatedModules","path":"isolatedmodules"},{"name":"listEmittedFiles","path":"listemittedfiles"},{"name":"listFiles","path":"listfiles"},{"name":"sourceRoot","path":"sourceroot"},{"name":"mapRoot","path":"maproot"},{"name":"maxNodeModuleJsDepth","path":"maxnodemodulejsdepth"},{"name":"project (p)","path":"project (p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version (v)"},{"name":"watch (w)","path":"watch (w)"},{"name":"preserveSymlinks","path":"preservesymlinks"},{"name":"strictFunctionTypes","path":"strictfunctiontypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctpropertyinitialization"},{"name":"esModuleInterop","path":"esmoduleinterop"},{"name":"emitDeclarationsOnly","path":"emitdeclarationsonly"},{"name":"resolveJsonModule","path":"resolvejsonmodule"},{"name":"declarationMap","path":"declarationmap"},{"name":"strictBindCallApply","path":"strictbindcallapply"},{"name":"showConfig","path":"showconfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsbuildinfofile"},{"name":"allowUmdGlobalAccess","path":"allowumdglobalaccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disablesourceofprojectreferenceredirect"},{"name":"useDefineForClassFields","path":"usedefineforclassfields"},{"name":"importsNotUsedAsValues","path":"importsnotusedasvalues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumechangesonlyaffectdirectdependencies"},{"name":"watchFile","path":"watchfile"},{"name":"watchDirectory","path":"watchdirectory"},{"name":"fallbackPolling","path":"fallbackpolling"},{"name":"synchronousWatchDirectory","path":"synchronouswatchdirectory"}]}]}},"staticQueryHashes":["408059355","63159454"]}