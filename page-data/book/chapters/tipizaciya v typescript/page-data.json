{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/tipizaciya v typescript","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Типизация в TypeScript","section":"Типизация","path":"tipizaciya v typescript","subtitles":[{"subtitle":"Общие сведения","path":"tipizaciya v typescript#obshchie svedeniya"},{"subtitle":"Статическая типизация (static typing)","path":"tipizaciya v typescript#staticheskaya tipizaciya (static typing)"},{"subtitle":"Сильная типизация (strongly typed)","path":"tipizaciya v typescript#silnaya tipizaciya (strongly typed)"},{"subtitle":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"tipizaciya v typescript#yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)"},{"subtitle":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"tipizaciya v typescript#sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)"},{"subtitle":"Вариантность (variance)","path":"tipizaciya v typescript#variantnost (variance)"},{"subtitle":"Наилучший общий тип (Best common type)","path":"tipizaciya v typescript#nailuchshii obshchii tip (best common type)"},{"subtitle":"Контекстный тип (Contextual Type)","path":"tipizaciya v typescript#kontekstnyi tip (contextual type)"},{"subtitle":"Итог","path":"tipizaciya v typescript#itog"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Типизация в TypeScript</span></h1><p class=\"content__paragraph\">Данная глава поможет разработчикам не просто писать типизированный код, а делать это в полной мере осмысленно. Для этого необходимо ещё раз повторить все концепции нашедшие свое применение в языке <em>TypeScript</em>.</p></section>\n<section class=\"content__section\" id=\"obshchie_svedeniya\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"obshchie svedeniya\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Общие сведения</span></h2><p class=\"content__paragraph\">Самое время взять паузу и рассмотреть типизацию в <em>TypeScript</em> более детально через призму полученных знаний.</p><p class=\"content__paragraph\">Итак, что известно о <em>TypeScript</em>? <em>TypeScript</em> это язык:</p><ol class=\"content__list\">\n<li>Статически типизированный с возможностью динамического связывания</li>\n<li>Сильно типизированный</li>\n<li>Явно типизированный с возможностью вывода типов</li>\n<li>Совместимость типов в <em>TypeScript</em> проходит по правилам структурной типизации </li>\n<li>Совместимость типов зависит от вариантности, чей конкретный вид определяется конкретным случаем</li>\n</ol><p class=\"content__paragraph\">Кроме этого существуют понятия которые входят в уже упомянутые, но которые в <em>TypeScript</em>, выделены в отдельные определения. По этой причине они будут рассматриваться отдельно. Такими понятиями являются: </p><ol class=\"content__list\">\n<li>Наилучший общий тип</li>\n<li>Контекстный тип</li>\n</ol><p class=\"content__paragraph\">Начнем с повторения определений в том порядке, в котором они были перечислены.</p></section>\n<section class=\"content__section\" id=\"staticheskaya_tipizaciya_(static_typing)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"staticheskaya tipizaciya (static typing)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Статическая типизация (static typing)</span></h2><p class=\"content__paragraph\"><em>Статическая типизация</em> обуславливается тем, что связывание с типом данных происходит на этапе компиляции и при этом тип не может изменится на протяжении всего своего существования.</p><p class=\"content__paragraph\">Статическая типизация в <em>TypeScript</em> проявляется в том, что к моменту окончания компиляции компилятору известно к какому конкретному типу принадлежат конструкции нуждающиеся в аннотации типа.</p></section>\n<section class=\"content__section\" id=\"silnaya_tipizaciya_(strongly_typed)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"silnaya tipizaciya (strongly typed)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Сильная типизация (strongly typed)</span></h2><p class=\"content__paragraph\">Язык с <em>сильной типизацией</em> не позволяет операции с несовместимыми типами данных, а также не выполняет явного преобразования типов.</p><p class=\"content__paragraph\">Сильная типизация в <em>TypeScript</em> проявляет себя в случаях схожих с операцией сложения числа с массивом. В этом случае компилятор выбрасывает ошибки.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> <span class=\"token number\">5</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"yavno_tipizirovannyi_(explicit_typing)_s_vyvodom_tipov_(type_inference)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Явно типизированный (explicit typing) с выводом типов (type inference)</span></h2><p class=\"content__paragraph\">Язык с <em>явной типизацией</em> предполагает, что указание типов будет выполнено разработчиком. Но современные языки с явной типизацией имеют возможность указывать типы неявно. Это становится возможным за счет механизма <em>вывода типов</em>.</p><p class=\"content__paragraph\">Вывод типов — это возможность компилятора (интерпретатора) самостоятельно выводить-указывать тип данных на основе анализа выражения.</p><p class=\"content__paragraph\">В <em>TypeScript</em>, если тип не указывается явно, компилятор с помощью вывода типов выводит и указывает тип самостоятельно.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> animal<span class=\"token operator\">:</span> Animal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animal: Animal</span>\n<span class=\"token keyword\">var</span> animal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animal: Animal</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"sovmestimost_tipov_(type_compatibility),_strukturnaya_tipizaciya_(structural_typing)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Совместимость типов (Type Compatibility), структурная типизация (structural typing)</span></h2><p class=\"content__paragraph\"><em>Совместимость типов</em> — это механизм по которому происходит сравнение типов.</p><p class=\"content__paragraph\">Простыми словами, совместимость типов — это совокупность правил, на основе которых программа анализируя два типа данных, выясняет, производить над ними операции считая их совместимыми, либо для этого требуется преобразование.</p><p class=\"content__paragraph\">Правила совместимости типов делятся на три вида, один из которых имеет название структурная типизация.</p><p class=\"content__paragraph\"><em>Структурная Типизация</em> - это принцип определяющий совместимость типов основываясь не на иерархии наследования или явной реализации интерфейсов, а на их описании.</p><p class=\"content__paragraph\">Несмотря на то, что <code>Bird</code> и <code>Fish</code> не имеют явно заданного общего предка, <em>TypeScript</em> разрешает присваивать экземпляр класса <code>Fish</code> переменной с типом <code>Bird</code> (и наоборот).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Fish</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Fish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> fish<span class=\"token operator\">:</span> Fish <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bird</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В таких языках, как <em>Java</em> или <em>C#</em>, подобное поведение недопустимо. В <em>TypeScript</em> это становится возможно из-за структурной типизации.</p><p class=\"content__paragraph\">Так как совместимость типов происходит на основе их описания, в первом случае компилятор запоминает все члены типа <code>Fish</code> и если он находит аналогичные члены в типе <code>Bird</code>, то они считаются совместимыми. То же самое компилятор проделывает тогда, когда во втором случае присваивает экземпляр класса <code>Bird</code> переменной с типом <code>Fish</code>. Так как оба типа имеют по одному полю, с одинаковым типом и идентификатором, то они считаются совместимыми.</p><p class=\"content__paragraph\">Если добавить классу <code>Bird</code> поле <code>wings</code>, то при попытке присвоить его экземпляр переменной с типом <code>Fish</code> возникнет ошибка, так как в типе <code>Fish</code> отсутствует после <code>wings</code>. Обратное действие, то есть присвоение экземпляра класса <code>Bird</code> переменной с типом <code>Fish</code>, ошибки не вызовет, так как в типе <code>Bird</code> будут найдены все члены объявленные в типе <code>Fish</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> wings<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Fish</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Fish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">var</span> fish<span class=\"token operator\">:</span> Fish <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bird</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Стоит добавить, что правилам структурной типизации подчиняются все объекты в <em>TypeScript</em>. А, как известно, в <em>JavaScript</em> все, кроме примитивных типов, объекты. Это же утверждение верно и для <em>TypeScript</em>.</p></section>\n<section class=\"content__section\" id=\"variantnost_(variance)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"variantnost (variance)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Вариантность (variance)</span></h2><p class=\"content__paragraph\">Простыми словами, <em>вариантность</em> — это механизм, определяющий правила на основе которых принимается решение о совместимости двух типов. Правила зависят от конкретного вида вариантности — <em>ковариантность</em>, <em>контравариантность</em>, <em>бивариантность</em> и <em>инвариантность</em>. В случае с <em>TypeScript</em> нас интересуют первые три.</p><p class=\"content__paragraph\">Ковариантность позволяет большему типу быть совместимым с меньшими типом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IBird</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IAnimal <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> v<span class=\"token operator\">:</span> IAnimal <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'animal'</span> \n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> IBird <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> v<span class=\"token operator\">:</span> IBird <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'bird'</span><span class=\"token punctuation\">,</span> \n        <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token punctuation\">}</span> \n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f0<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f1<span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> <span class=\"token constant\">T0</span> <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n<span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> <span class=\"token constant\">T1</span> <span class=\"token operator\">=</span> f0<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Контравариантность позволяет меньшему типу быть совместимым с большим типом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IBird</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f0</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IAnimal<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IBird<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f0<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f1<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> <span class=\"token constant\">T0</span> <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> <span class=\"token constant\">T1</span> <span class=\"token operator\">=</span> f0<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Бивариантность, доступная исключительно для параметров функций при условии, что флаг <code>--strictFunctionTypes</code> установлен в значение <code>false</code>, делает возможной совместимость как большего типа с меньшим, так и наоборот — меньшего с большим.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IBird</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IAnimal</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f0</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IAnimal<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> IBird<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f0<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> f1<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> <span class=\"token constant\">T0</span> <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok, (--strictFunctionTypes === false)</span>\n<span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> <span class=\"token constant\">T1</span> <span class=\"token operator\">=</span> f0<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Не будет лишним упомянуть, что бивариантность снижает уровень типобезопасности программы и поэтому рекомендуется вести разработку с флагом <code>--strictFunctionTypes</code> установленным в значение <code>true</code>.</p></section>\n<section class=\"content__section\" id=\"nailuchshii_obshchii_tip_(best_common_type)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"nailuchshii obshchii tip (best common type)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Наилучший общий тип (Best common type)</span></h2><p class=\"content__paragraph\">С выводом типов в <em>TypeScript</em> связано такое понятие, как наилучший общий тип. Это очень простое правило, название которого в большей мере раскрывает его суть. </p><p class=\"content__paragraph\">Как уже было сказано, <em>TypeScript</em> — статически типизированный язык, и поэтому он пытается всему указать типы. В случаях, когда тип не был указан явно, в работу включается вывод типов. Предположим, что существует массив ссылка на который присваивается переменной объявленной без явного указания типа. Для того, чтобы вывод типов смог вывести тип для переменной, ему нужно проанализировать данные хранящиеся в массиве (если они хранятся).</p><p class=\"content__paragraph\">Для примера представьте массив хранящий экземпляры классов <code>Animal</code>, <code>Elephant</code> и <code>Lion</code> последнии два из которых расширяют первый. И кроме того ссылка на данный массив присваивается переменной.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Elephant</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Lion</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> animalAll <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elephant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animalAll: Animal[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Так как <em>TypeScript</em> проверяет совместимость типов по правилам структурной типизации и все три типа идентичны с точки зрения их описания, то с точки зрения вывода типов все они идентичны. Поэтому он выберет в качестве типа тот который является более общим, то есть тип <code>Animal</code>.</p><p class=\"content__paragraph\">Если типу <code>Elephant</code> будет добавлено поле, например, хобот (<code>trunk</code>), что сделает его отличным от всех, то вывод типов будет вынужден указать массиву базовый для всех типов тип <code>Animal</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Elephant</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> thrunk<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Lion</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> animalAll <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elephant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lion</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animalAll: Animal[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случае, если в массиве не будет присутствовать базовый для всех типов тип <code>Animal</code>, то вывод типов будет расценивать массив как принадлежащий к типу объединение <code>Elephant | Lion</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Elephant</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> thrunk<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Lion</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> animalAll <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Elephant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// animalAll: (Elephant | Lion)[]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Как видно, ничего неожиданного или сложного в теме наилучшего общего типа совершенно нет.</p></section>\n<section class=\"content__section\" id=\"kontekstnyi_tip_(contextual_type)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"kontekstnyi tip (contextual type)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Контекстный тип (Contextual Type)</span></h2><p class=\"content__paragraph\">Контекстным называется тип который при не явном объявлении указывается за счет декларации контекста, а не с помощью вывода типов.</p><p class=\"content__paragraph\">Лучшим примером контекстного типа может служить подписка <code>document</code> на событие мыши <code>mousedown</code>. Так как у слушателя события тип параметра <code>event</code> не указан явно, а также ему в момент объявления не было присвоено значение, то вывод типов должен был указать тип <code>any</code>. Но в данном случае компилятор указывает тип <code>MouseEvent</code>, потому что именно он указан в декларации типа слушателя событий. В случае подписания <code>document</code> на событие <code>keydown</code>, компилятор указывает тип как <code>KeyboardEvent</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'mousedown'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// event: MouseEvent</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'keydown'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// event: KeyboardEvent</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Для того чтобы понять, как это работает, опишем случай из жизни зоопарка — представление с морским львом. Для этого создадим класс морской лев <code>SeaLion</code> и объявим в нем два метода: вращаться (<code>rotate</code>) и голос (<code>voice</code>).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SeaLion</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">voice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Далее, создадим класс дрессировщик <code>Trainer</code> и объявим в нем метод <code>addEventListener</code> с двумя параметрами: <code>type</code> с типом <code>string</code> и <code>handler</code> с типом <code>Function</code>. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trainer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Затем объявим два класса события, выражающие команды дрессировщика <code>RotateTrainerEvent</code> и <code>VoiceTrainerEvent</code>. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">RotateTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">VoiceTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">После объявим два псевдонима (<code>type</code>) для литеральных типов <code>string</code>. Первому зададим имя <code>RotateEventType</code> и в качестве значения присвоим строковой литерал <code>\"rotate\"</code>. Второму зададим имя <code>VoiceEventType</code> и в качестве  значения присвоим строковой литерал <code>\"voice\"</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"rotate\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"voice\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Теперь осталось только задекларировать ещё два псевдонима типов для функциональных типов у обоих из которых будет один параметр <code>event</code> и отсутствовать возвращаемое значение. Первому псевдониму зададим имя <code>RotateTrainerHandler</code>, а его параметру установим тип  <code>RotateTrainerEvent</code>. Второму псевдониму зададим имя <code>VoiceTrainerHandler</code>, а его параметру установим тип <code>VoiceTrainerEvent</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> RotateTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> VoiceTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Соберём части воедино. Для этого в классе дрессировщик <code>Trainer</code> перегрузим метод <code>addEventListener</code>. У первого перегруженного метода параметр <code>type</code> будет иметь тип <code>RotateEventType</code>, а параметру <code>handler</code> укажем тип <code>RotateTrainerHandler</code>. Второму перегруженному методу в качестве типа параметра <code>type</code> укажем <code>VoiceEventType</code>, а параметру <code>handler</code> укажем тип <code>VoiceTrainerHandler</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trainer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> RotateEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> RotateTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> VoiceEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> VoiceTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Осталось только убедиться что все работает правильно. Для этого создадим экземпляр класса <code>Trainer</code> и подпишемся на события. Сразу же можно увидеть подтверждение того, что цель достигнута. У слушателя события <code>RotateTrainerEvent</code> параметру <code>event</code> указан контекстный тип <code>RotateTrainerEvent</code>. А слушателю события <code>VoiceTrainerEvent</code> параметру <code>event</code> указан контекстный тип <code>VoiceTrainerEvent</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> RotateTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceTrainerHandler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> VoiceTrainerEvent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">RotateEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"rotate\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">VoiceEventType</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"voice\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RotateTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">VoiceTrainerEvent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SeaLion</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">voice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Trainer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> RotateEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> RotateTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> VoiceEventType<span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> VoiceTrainerHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> handler<span class=\"token operator\">:</span> <span class=\"token builtin\">Function</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> seaLion<span class=\"token operator\">:</span> SeaLion <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SeaLion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> trainer<span class=\"token operator\">:</span> Trainer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Trainer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntrainer<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'rotate'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> seaLion<span class=\"token punctuation\">.</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntrainer<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'voice'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> seaLion<span class=\"token punctuation\">.</span><span class=\"token function\">voice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"itog\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"itog\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Итог</span></h2><ul class=\"content__list\">\n<li><em>TypeScript</em> — это статически типизированный язык, а это говорит о том, что значение связывается с типом данных на этапе компиляции, при этом тип остается неизменным.</li>\n<li><em>TypeScript</em> — это язык с сильной типизацией, которая не позволяет операции с несовместимыми типами данных и не выполняет их неявных преобразований в случаях, в которых требуется явное приведение.</li>\n<li><em>TypeScript</em> — это явно типизированный язык с возможностью вывода типов. Это говорит о том, что <em>TypeScript</em> настаивает на указании типов явно, а в случаях неявного указания прибегает к выводу типов.</li>\n<li><em>TypeScript</em> проверяет типы на совместимость на основе правил структурной типизации, при которой два типа считаются совместимыми, если у приводимого типа найдены все члены типа, к которому приводят.</li>\n<li>Наилучший общий тип выбирается на основе типов данных, присутствующих в выражения.</li>\n<li>Контекстный тип устанавливается не за счет вывода типов, а за счет контекста.</li>\n</ul></section>","commitInfoAll":[{"committedDate":"2020-09-08T11:53:53Z","message":"book(технические изменения (link, md, т.п.)): change code wrapper\n\nchange code wrapper from ~ to ` and from typescript to ts","messageHeadline":"book(технические изменения (link, md, т.п.)): change code wrapper","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars3.githubusercontent.com/u/31518738?v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/041\\.\\(Типизация\\) Типизация в TypeScript/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"chto takoe i dlya chego nujen typescript","sections":[{"name":"Что такое TypeScript","path":"chto takoe typescript"},{"name":"История TypeScript","path":"istoriya typescript"},{"name":"Для чего нужен TypeScript","path":"dlya chego nujen typescript"},{"name":"Зачем разработчику TypeScript","path":"zachem razrabotchiku typescript"}]},{"name":"Вступление","path":"vstuplenie","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"sistema tipov, tip dannyh, znachimye i ssylochnye tipy","sections":[{"name":"Система Типов","path":"sistema tipov"},{"name":"Тип данных (тип)","path":"tip dannyh (tip)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"tip dannyh, peredaushchiisya po znacheniu (primitivnyi tip)"},{"name":"Тип данных, передающийся по ссылке","path":"tip dannyh, peredaushchiisya po ssylke"}]},{"name":"Связывание, типизация, вывод типов","path":"svyazyvanie, tipizaciya, vyvod tipov","sections":[{"name":"Обработка кода компилятором","path":"obrabotka koda kompilyatorom"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"leksicheskii analiz (tokenizaciya - tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"sintaksicheskii analiz (razbor - parsing)"},{"name":"Семантический анализ","path":"semanticheskii analiz"},{"name":"Связывание (Binding)","path":"svyazyvanie (binding)"},{"name":"Типизация","path":"tipizaciya"},{"name":"Вывод Типов (type inference)","path":"vyvod tipov (type inference)"}]},{"name":"Преобразование типов","path":"preobrazovanie tipov","sections":[{"name":"Неявные Преобразования","path":"neyavnye preobrazovaniya"},{"name":"Явные Преобразования","path":"yavnye preobrazovaniya"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"tipizirovannye i netipizirovannye yazyki programmirovaniya","sections":[{"name":"Нетипизированные языки","path":"netipizirovannye yazyki"},{"name":"Типизированные языки","path":"tipizirovannye yazyki"}]},{"name":"Статическая и динамическая типизация","path":"staticheskaya i dinamicheskaya tipizaciya","sections":[{"name":"Статическая типизация (Static Typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"dinamicheskaya tipizaciya (dynamic typing)"}]},{"name":"Сильная и слабая типизация","path":"silnaya i slabaya tipizaciya","sections":[{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Слабая типизация (weakly typed)","path":"slabaya tipizaciya (weakly typed)"}]},{"name":"Явная и неявная типизация","path":"yavnaya i neyavnaya tipizaciya","sections":[{"name":"Явная типизация (explicit typing)","path":"yavnaya tipizaciya (explicit typing)"},{"name":"Неявная типизация (implicit typing)","path":"neyavnaya tipizaciya (implicit typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"sovmestimost tipov na osnove vida tipizacii","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"sovmestimost tipov (types compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"nominativnaya tipizaciya (nominative typing)"},{"name":"Структурная Типизация (structural typing)","path":"strukturnaya tipizaciya (structural typing)"},{"name":"Утиная Типизация (Duck typing)","path":"utinaya tipizaciya (duck typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"sovmestimost tipov na osnove variantnosti","sections":[{"name":"Вариантность","path":"variantnost"},{"name":"Иерархия наследования","path":"ierarhiya nasledovaniya"},{"name":"Ковариантность","path":"kovariantnost"},{"name":"Контравариантность","path":"kontravariantnost"},{"name":"Инвариантность","path":"invariantnost"},{"name":"Бивариантность","path":"bivariantnost"}]},{"name":"Аннотация Типов","path":"annotaciya tipov","sections":[{"name":"Аннотация Типов - общее","path":"annotaciya tipov - obshchee"},{"name":"Аннотация типа","path":"annotaciya tipa"},{"name":"Синтаксические конструкции var, let, const","path":"sintaksicheskie konstrukcii var, let, const"},{"name":"Функции (function)","path":"funkcii (function)"},{"name":"Стрелочные Функции (arrow function)","path":"strelochnye funkcii (arrow function)"},{"name":"Классы (class)","path":"klassy (class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"sravnenie sintaksisa typescript i javascript"},{"name":"Итог","path":"itog"}]},{"name":"Базовый Тип Any","path":"bazovyi tip any","sections":[{"name":"Any (any) произвольный тип","path":"any (any) proizvolnyi tip"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"primitivnye tipy number, string, boolean, symbol, bigint","sections":[{"name":"Важно","path":"vajno"},{"name":"Number (number) примитивный числовой тип","path":"number (number) primitivnyi chislovoi tip"},{"name":"String (string) примитивный строковый тип","path":"string (string) primitivnyi strokovyi tip"},{"name":"Boolean (boolean) примитивный логический тип","path":"boolean (boolean) primitivnyi logicheskii tip"},{"name":"Symbol (symbol) примитивный символьный тип","path":"symbol (symbol) primitivnyi simvolnyi tip"},{"name":"BigInt (bigint) примитивный числовой тип","path":"bigint (bigint) primitivnyi chislovoi tip"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"primitivnye tipy null, undefined, void, never, unknown","sections":[{"name":"Важно","path":"vajno"},{"name":"Null (null) примитивный null тип","path":"null (null) primitivnyi null tip"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"undefined (undefined) primitivnyi neopredelennyi tip"},{"name":"Void (void) отсутствие конкретного типа","path":"void (void) otsutstvie konkretnogo tipa"},{"name":"Never (never) примитивный тип","path":"never (never) primitivnyi tip"},{"name":"Unknown (unknown)","path":"unknown (unknown)"}]},{"name":"Примитивный Тип Enum","path":"primitivnyi tip enum","sections":[{"name":"Enum (enum) примитивный перечисляемый тип","path":"enum (enum) primitivnyi perechislyaemyi tip"},{"name":"Перечисления с числовым значением","path":"perechisleniya s chislovym znacheniem"},{"name":"Перечисления со строковым значением","path":"perechisleniya so strokovym znacheniem"},{"name":"Смешанное перечисление (mixed enum)","path":"smeshannoe perechislenie (mixed enum)"},{"name":"Перечисление в качестве типа данных","path":"perechislenie v kachestve tipa dannyh"},{"name":"Перечисление const с числовым и строковым значением","path":"perechislenie const s chislovym i strokovym znacheniem"},{"name":"Когда стоит применять enum?","path":"kogda stoit primenyat enum?"}]},{"name":"Типы - Union, Intersection","path":"tipy - union, intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"tip obedinenie (union types)"},{"name":"Тип Пересечение (Intersection Type)","path":"tip peresechenie (intersection type)"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"type queries (zaprosy tipa), alias (psevdonimy tipa)","sections":[{"name":"Запросы Типа (Type Queries)","path":"zaprosy tipa (type queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"psevdonimy tipov (type aliases)"}]},{"name":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"primitivnye literalnye tipy number, string, template string, boolean, unique symbol, enum","sections":[{"name":"Литеральный тип Number (Numeric Literal Types)","path":"literalnyi tip number (numeric literal types)"},{"name":"Литеральный тип String (String Literal Types)","path":"literalnyi tip string (string literal types)"},{"name":"Шаблонный литеральный тип String (Template String Literal Types)","path":"shablonnyi literalnyi tip string (template string literal types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"literalnyi tip boolean (boolean literal types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"literalnyi tip unique symbol (unique symbol) unikalnyi simvolnyi tip"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"literalnyi tip enum (enum literal types)"}]},{"name":"Object, Array, Tuple","path":"object, array, tuple","sections":[{"name":"Object (object) — ссылочный объектный тип","path":"object (object) — ssylochnyi obektnyi tip"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"array (type[]) ssylochnyi massivopodobnyi tip"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"tuple ([t0, t1, …, tn]) tip kortej"}]},{"name":"Function, Functional Types","path":"function, functional types","sections":[{"name":"Function Types - тип функция","path":"function types - tip funkciya"},{"name":"Functional Types - функциональный тип","path":"functional types - funkcionalnyi tip"},{"name":"this в сигнатуре функции","path":"this v signature funkcii"}]},{"name":"Interfaces","path":"interfaces","sections":[{"name":"Общая теория","path":"obshchaya teoriya"},{"name":"Интерфейс в TypeScript","path":"interfeis v typescript"},{"name":"Объявление (declaration)","path":"obyavlenie (declaration)"},{"name":"Конвенции именования интерфейсов","path":"konvencii imenovaniya interfeisov"},{"name":"Реализация интерфейса (implements)","path":"realizaciya interfeisa (implements)"},{"name":"Декларация свойств get и set (accessors)","path":"deklaraciya svoistv get i set (accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"ukazanie interfeisa v kachestve tipa (interface types)"},{"name":"Расширение интерфейсов (extends interface)","path":"rasshirenie interfeisov (extends interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"rasshirenie interfeisom klassa (extends class)"},{"name":"Описание класса (функции-конструктора)","path":"opisanie klassa (funkcii-konstruktora)"},{"name":"Описание функционального выражения","path":"opisanie funkcionalnogo vyrajeniya"},{"name":"Описание индексных членов в объектных типов","path":"opisanie indeksnyh chlenov v obektnyh tipov"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"inlain interfeisy (inline interface)"},{"name":"Слияние интерфейсов","path":"sliyanie interfeisov"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)","sections":[{"name":"Индексные члены (определение динамических ключей)","path":"indeksnye chleny (opredelenie dinamicheskih kluchei)"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)","sections":[{"name":"Модификатор доступа public (публичный)","path":"modifikator dostupa public (publichnyi)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"modifikator dostupa private (zakrytyi ili skrytyi)"},{"name":"Модификатор доступа protected (защищенный)","path":"modifikator dostupa protected (zashchishchennyi)"},{"name":"Модификаторы доступа и конструкторы класса","path":"modifikatory dostupa i konstruktory klassa"},{"name":"Быстрое объявление полей","path":"bystroe obyavlenie polei"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript","sections":[{"name":"Нативный закрытый (private) модификатор доступа","path":"nativnyi zakrytyi (private) modifikator dostupa"}]},{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)","sections":[{"name":"Общие характеристики","path":"obshchie harakteristiki"},{"name":"Теория","path":"teoriya"}]},{"name":"Полиморфный тип this","path":"polimorfnyi tip this","sections":[{"name":"this - как тип","path":"this - kak tip"}]},{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)","sections":[{"name":"Модификатор readonly","path":"modifikator readonly"}]},{"name":"Definite Assignment Assertion Modifier","path":"definite assignment assertion modifier","sections":[{"name":"Модификатор утверждения не принадлежности значения к типу undefined","path":"modifikator utverjdeniya ne prinadlejnosti znacheniya k tipu undefined"}]},{"name":"Классы — Тонкости","path":"klassy — tonkosti","sections":[{"name":"Классы — Тонкости","path":"klassy — tonkosti"},{"name":"Классы - Тонкости implements","path":"klassy - tonkosti implements"},{"name":"Частичное Слияние интерфейса с классом","path":"chastichnoe sliyanie interfeisa s klassom"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"pereopredelenie svoistv polyami i naoborot pri nasledovanii"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov","sections":[{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov"},{"name":"Итог","path":"itog"}]},{"name":"Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"optional, not-null, not-undefined, definite assignment assertion","sections":[{"name":"Операторы — Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"operatory — optional, not-null, not-undefined, definite assignment assertion"},{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"neobyazatelnye polya, parametry i metody (optional fields, parameters and methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"operator ! (non-null and non-undefined operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"operator ! (definite assignment assertion)"},{"name":"Итог","path":"itog"}]},{"name":"Обобщения (Generics)","path":"obobshcheniya (generics)","sections":[{"name":"Обобщения - общие понятия","path":"obobshcheniya - obshchie ponyatiya"},{"name":"Обобщения в TypeScript","path":"obobshcheniya v typescript"},{"name":"Параметры типа - extends (generic constraints)","path":"parametry tipa - extends (generic constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"parametra tipa - znachenie po umolchaniu = (generic parameter defaults)"},{"name":"Параметры типа - как тип данных","path":"parametry tipa - kak tip dannyh"}]},{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)","sections":[{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)"}]},{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa","sections":[{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa"}]},{"name":"Утверждение Типов (Type Assertion)","path":"utverjdenie tipov (type assertion)","sections":[{"name":"Утверждение Типов - общее","path":"utverjdenie tipov - obshchee"},{"name":"Утверждение Типа `<Type>` синтаксис","path":"utverjdenie tipa `<type>` sintaksis"},{"name":"Утверждение Типа с помощью оператора as","path":"utverjdenie tipa s pomoshchu operatora as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"privedenie (utverjdenie) k konstante (const assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"utverjdenie v signature (signature assertion)"},{"name":"Итоги","path":"itogi"}]},{"name":"Защитники типа","path":"zashchitniki tipa","sections":[{"name":"Защитники Типа - общее","path":"zashchitniki tipa - obshchee"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"sujenie diapazona mnojestva tipov na osnove tipa dannyh"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"sujenie diapazona mnojestva tipov na osnove priznakov prisushchih tipu tagged union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"sujenie diapazona mnojestva tipov na osnove dostupnyh chlenov obekta"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"sujenie diapazona mnojestva tipov na osnove funkcii, opredelennoi polzovatelem"}]},{"name":"Вывод типов","path":"vyvod tipov","sections":[{"name":"Вывод типов - общие сведения","path":"vyvod tipov - obshchie svedeniya"},{"name":"Вывод примитивных типов","path":"vyvod primitivnyh tipov"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"vyvod primitivnyh tipov dlya konstant (const) i polei tolko dlya chteniya (readonly)"},{"name":"Вывод объектных типов","path":"vyvod obektnyh tipov"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"vyvod tipa dlya polei klassa na osnove inicializacii ih v konstruktore"},{"name":"Вывод объединенных (Union) типов","path":"vyvod obedinennyh (union) tipov"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"vyvod peresecheniya (intersection) s diskriminantnymi polyami"},{"name":"Вывод типов кортеж (Tuple)","path":"vyvod tipov kortej (tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"sovmestimost obektnyh tipov (compatible object types)","sections":[{"name":"Важно","path":"vajno"},{"name":"Совместимость объектных типов в TypeScript","path":"sovmestimost obektnyh tipov v typescript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"sovmestimost funkcionalnyh tipov (compatible function types)","sections":[{"name":"важно","path":"vajno"},{"name":"Совместимость параметров","path":"sovmestimost parametrov"},{"name":"Совместимость возвращаемого значения","path":"sovmestimost vozvrashchaemogo znacheniya"}]},{"name":"Совместимость объединений (Union Types)","path":"sovmestimost obedinenii (union types)","sections":[{"name":"Совместимость","path":"sovmestimost"}]},{"name":"Типизация в TypeScript","path":"tipizaciya v typescript","sections":[{"name":"Общие сведения","path":"obshchie svedeniya"},{"name":"Статическая типизация (static typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)"},{"name":"Вариантность (variance)","path":"variantnost (variance)"},{"name":"Наилучший общий тип (Best common type)","path":"nailuchshii obshchii tip (best common type)"},{"name":"Контекстный тип (Contextual Type)","path":"kontekstnyi tip (contextual type)"},{"name":"Итог","path":"itog"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -","sections":[{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -"},{"name":"Запрос ключей keyof","path":"zapros kluchei keyof"},{"name":"Поиск типов (Lookup Types)","path":"poisk tipov (lookup types)"},{"name":"Сопоставление типов (Mapped Types)","path":"sopostavlenie tipov (mapped types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"prefiksy + i - v sopostavlennyh tipah"}]},{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)","sections":[{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"raspredelitelnye uslovnye tipy (distributive conditional types)"},{"name":"Вывод типов в условном типе","path":"vyvod tipov v uslovnom tipe"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"readonly, partial, required, pick, record","sections":[{"name":"Расширенные типы — Readonly, Partial, Required, Pick, Record","path":"rasshirennye tipy — readonly, partial, required, pick, record"},{"name":"Readonly","path":"readonly"},{"name":"Partial","path":"partial"},{"name":"Required","path":"required"},{"name":"Pick","path":"pick"},{"name":"Record","path":"record"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"exclude, extract, nonnullable, returntype, instancetype, omit","sections":[{"name":"Расширенные типы — Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"rasshirennye tipy — exclude, extract, nonnullable, returntype, instancetype, omit"},{"name":"Exclude","path":"exclude"},{"name":"Extract","path":"extract"},{"name":"NonNullable","path":"nonnullable"},{"name":"ReturnType","path":"returntype"},{"name":"InstanceType","path":"instancetype"},{"name":"Parameters","path":"parameters"},{"name":"ConstructorParameters","path":"constructorparameters"},{"name":"Тип Omit","path":"tip omit"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"massivopodobnye readonly tipy, readonlyarray, readonlymap, readonlyset","sections":[{"name":"Массивоподобные readonly типы","path":"massivopodobnye readonly tipy"},{"name":"ReadonlyArray","path":"readonlyarray"},{"name":"ReadonlyMap","path":"readonlymap"},{"name":"ReadonlySet","path":"readonlyset"}]},{"name":"Синтаксические конструкции и операторы","path":"sintaksicheskie konstrukcii i operatory","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"operatory prisvaivaniya korotkogo zamykaniya (&&=, ||=, &&=)"},{"name":"Операнды для delete должны быть необязательными","path":"operandy dlya delete doljny byt neobyazatelnymi"}]},{"name":"React - расширение .tsx","path":"react - rasshirenie .tsx","sections":[{"name":"React — расширение .tsx","path":"react — rasshirenie .tsx"}]},{"name":"Функциональные компоненты","path":"funkcionalnye komponenty","sections":[{"name":"Определение компонента как Function Declaration","path":"opredelenie komponenta kak function declaration"},{"name":"Определение компонента как Function Expression","path":"opredelenie komponenta kak function expression"}]},{"name":"Классовые компоненты","path":"klassovye komponenty","sections":[{"name":"React — производные от Component","path":"react — proizvodnye ot component"},{"name":"React - производные от PureComponent","path":"react - proizvodnye ot purecomponent"}]},{"name":"Универсальные компоненты","path":"universalnye komponenty","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"obobshchennye komponenty (generics component)"}]},{"name":"Типизированные хуки","path":"tipizirovannye huki","sections":[{"name":"Предопределенные хуки","path":"predopredelennye huki"},{"name":"Пользовательский хук","path":"polzovatelskii huk"}]},{"name":"Контекст (Context)","path":"kontekst (context)","sections":[{"name":"Определение контекста","path":"opredelenie konteksta"}]},{"name":"HOC (Higher-Order Components)","path":"hoc (higher-order components)","sections":[{"name":"Определение hoc","path":"opredelenie hoc"},{"name":"Определение hoc на основе функционального компонента","path":"opredelenie hoc na osnove funkcionalnogo komponenta"},{"name":"Определение hoc на основе классового компонента","path":"opredelenie hoc na osnove klassovogo komponenta"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"prostranstva imen (namespace) i moduli (module)","sections":[{"name":"Namespace и module — предназначение","path":"namespace i module — prednaznachenie"},{"name":"Namespace - определение","path":"namespace - opredelenie"},{"name":"Модули (export, import) — определение","path":"moduli (export, import) — opredelenie"},{"name":"Конфигурирование проекта","path":"konfigurirovanie proekta"}]},{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya","sections":[{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"sborka proekta s pomoshchu tsc (typescript compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"sborka s ispolzovaniem ssylok na proekty","sections":[{"name":"Ссылки на проекты","path":"ssylki na proekty"}]},{"name":"Декларации","path":"deklaracii","sections":[{"name":"Что такое декларация (Declaration)","path":"chto takoe deklaraciya (declaration)"},{"name":"Установка деклараций с помощью @types","path":"ustanovka deklaracii s pomoshchu @types"},{"name":"Подготовка к созданию декларации","path":"podgotovka k sozdaniu deklaracii"},{"name":"Разновидности деклараций","path":"raznovidnosti deklaracii"},{"name":"Декларации и область видимости","path":"deklaracii i oblast vidimosti"},{"name":"Декларации для библиотек с одной точкой входа","path":"deklaracii dlya bibliotek s odnoi tochkoi vhoda"},{"name":"Декларации для библиотек с множеством точек входа","path":"deklaracii dlya bibliotek s mnojestvom tochek vhoda"},{"name":"Создание деклараций вручную","path":"sozdanie deklaracii vruchnuu"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"direktiva s troinym sleshem (triple-slash directives)"},{"name":"Импортирование декларации (import)","path":"importirovanie deklaracii (import)"}]},{"name":"Публикация","path":"publikaciya","sections":[{"name":"Публикация","path":"publikaciya"}]},{"name":"Опции компилятора","path":"opcii kompilyatora","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressexcesspropertyerrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressimplicitanyindexerrors"},{"name":"noImplicitAny","path":"noimplicitany"},{"name":"checkJs","path":"checkjs"},{"name":"JSX","path":"jsx"},{"name":"jsxFactory","path":"jsxfactory"},{"name":"target (t)","path":"target (t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysstrict"},{"name":"strictNullChecks","path":"strictnullchecks"},{"name":"stripInternal","path":"stripinternal"},{"name":"noImplicitThis","path":"noimplicitthis"},{"name":"noImplicitUseStrict","path":"noimplicitusestrict"},{"name":"baseUrl","path":"baseurl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootdir"},{"name":"rootDirs","path":"rootdirs"},{"name":"traceResolution","path":"traceresolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"nolib"},{"name":"noResolve","path":"noresolve"},{"name":"noStrictGenericChecks","path":"nostrictgenericchecks"},{"name":"preserveConstEnums","path":"preserveconstenums"},{"name":"removeComments","path":"removecomments"},{"name":"noUnusedLocals","path":"nounusedlocals"},{"name":"noUnusedParameters","path":"nounusedparameters"},{"name":"skipLibCheck","path":"skiplibcheck"},{"name":"declarationDir","path":"declarationdir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeroots"},{"name":"allowUnusedLabels","path":"allowunusedlabels"},{"name":"noImplicitReturns","path":"noimplicitreturns"},{"name":"noFallthroughCasesInSwitch","path":"nofallthroughcasesinswitch"},{"name":"outFile","path":"outfile"},{"name":"allowSyntheticDefaultImports","path":"allowsyntheticdefaultimports"},{"name":"allowUnreachableCode","path":"allowunreachablecode"},{"name":"allowJs","path":"allowjs"},{"name":"reactNamespace","path":"reactnamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleresolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noemithelpers"},{"name":"newLine","path":"newline"},{"name":"inlineSourceMap","path":"inlinesourcemap"},{"name":"inlineSources","path":"inlinesources"},{"name":"noEmitOnError","path":"noemitonerror"},{"name":"noEmit","path":"noemit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downleveliteration"},{"name":"emitBOM","path":"emitbom"},{"name":"emitDecoratorMetadata","path":"emitdecoratormetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceconsistentcasinginfilenames"},{"name":"help (h)","path":"help (h)"},{"name":"importHelpers","path":"importhelpers"},{"name":"isolatedModules","path":"isolatedmodules"},{"name":"listEmittedFiles","path":"listemittedfiles"},{"name":"listFiles","path":"listfiles"},{"name":"sourceRoot","path":"sourceroot"},{"name":"mapRoot","path":"maproot"},{"name":"maxNodeModuleJsDepth","path":"maxnodemodulejsdepth"},{"name":"project (p)","path":"project (p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version (v)"},{"name":"watch (w)","path":"watch (w)"},{"name":"preserveSymlinks","path":"preservesymlinks"},{"name":"strictFunctionTypes","path":"strictfunctiontypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctpropertyinitialization"},{"name":"esModuleInterop","path":"esmoduleinterop"},{"name":"emitDeclarationsOnly","path":"emitdeclarationsonly"},{"name":"resolveJsonModule","path":"resolvejsonmodule"},{"name":"declarationMap","path":"declarationmap"},{"name":"strictBindCallApply","path":"strictbindcallapply"},{"name":"showConfig","path":"showconfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsbuildinfofile"},{"name":"allowUmdGlobalAccess","path":"allowumdglobalaccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disablesourceofprojectreferenceredirect"},{"name":"useDefineForClassFields","path":"usedefineforclassfields"},{"name":"importsNotUsedAsValues","path":"importsnotusedasvalues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumechangesonlyaffectdirectdependencies"},{"name":"watchFile","path":"watchfile"},{"name":"watchDirectory","path":"watchdirectory"},{"name":"fallbackPolling","path":"fallbackpolling"},{"name":"synchronousWatchDirectory","path":"synchronouswatchdirectory"}]}]}},"staticQueryHashes":["408059355","63159454"]}