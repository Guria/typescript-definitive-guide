{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/funkcionalnye komponenty","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Функциональные компоненты","section":"React","path":"funkcionalnye komponenty","subtitles":[{"subtitle":"Определение компонента как Function Declaration","path":"funkcionalnye komponenty#opredelenie komponenta kak function declaration"},{"subtitle":"Определение компонента как Function Expression","path":"funkcionalnye komponenty#opredelenie komponenta kak function expression"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Функциональные компоненты</span></h1><p>Поскольку создавать <em>React</em> приложения рекомендуется на основе функциональных компонентов, то именно с них и начнется погружение в типизирование <code>.tsx</code> конструкций.</p><p>Всем известно что <em>React</em> компоненты обозначаемые как <em>функциональные</em> представляют из себя самые обычные функции. И как все функции в <em>JavaScript</em> они также мгут быть определены двумя способами — в виде обычной функции (<em>Function Declaration</em>) и в виде функционального выражения (<em>Function Expression</em>) тоящего один неочевидный нюанс, который подробно будет рассмотрен по ходу знакомства с ним.</p></section>\n<section class=\"content__section\" id=\"opredelenie_komponenta_kak_function_declaration\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"opredelenie komponenta kak function declaration\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Определение компонента как Function Declaration</span></h2><p>Факт что функциональный компонент является обычной функций предполагает необходимость в типизировании её сигнатуры. Точнее её параметров при условии их необходимости, так как указание типа возвращаемого значения не просто можно, а даже рекоментдуется опустить, возложив эту работу на вывод типов. Также необходимо всегда помнить что независимо от того используется пространство имен <code>React</code> непосредственно или нет, модули определяющие <em>React</em> компоненты обязанны его импортировать. В противном случае компилятор напомнит об этом с помощью ошибки.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">      /**[0] */\nimport React from &quot;react&quot;;\n\n/**[1] */ \nfunction Timer(/**[2] */) /**[3] */ {\n  return &lt;div&gt;Is Timer!&lt;/div&gt;;\n}\n\nexport default Timer;\n\n/**\n * [1] функциональный компонент\n * определенный как Function Declaration.\n * [2] отсутствующие параметры.\n * [3] отсутствие явного указания типа\n * возвращаемого типа.\n * [0] все компоненты обязаны импортировать\n * пространство имен React.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>При определении первого параметра функционального компонента <code>props</code> появляется потребность в типе описывающем их. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">/**[0] */\ninterface Props {\n  message?: string; /**[1] */\n  duration: number; /**[2] */\n}\n\n                                            /**[3] */\nfunction Timer({duration, message = `Done!`}: Props) {\n  return &lt;div&gt;&lt;/div&gt;;\n}\n\n/**\n * [0] определения типа интерфейса\n * который будет указан в аннотации\n * первого параметра функционального\n * компонента [3] и чье описание \n * включает необязательное поле message [1]\n *  и обязательного duration [2] \n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Поскольку идеология <em>React</em> подразумевает <em>прокидование пропсов</em> из одного компонента в другой, то компоненту выступающему в роли провайдера помимо своих пропсов необходимо описывать пропсы своих детей. В случаях когда в проброске нуждаются только несколько значений принадлежащих к типам из системы типов <em>TypeScript</em>, декларирование их в пропсах провайдера не будет выглядеть удручающе.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// file Informer.tsx\n\n/**[0] */\ninterface Props {\n    message: string;\n}\n\n/**\n * [0] описание пропсов компонента Informer\n */\n\nexport default function Informer({message}: Props){\n  return &lt;h1&gt;{message}&lt;/h1&gt;\n}\n\n\n\n// file InformerDecorator.tsx\n\nimport Informer from &quot;./Informer&quot;;\n\n\n/**[0] */\ninterface Props {\n    decor: number; /**[1] */\n    message: string; /**[2] */\n}\n\n/**\n * [0] описание пропсов компонента InformerDecorator\n * [1] значение предназначаемое непосредственно текущему компоненту\n * [2] значение предназначаемое компоненту Informer\n */\n\nexport default function InformerDecorator({decor, message}: Props){\n  return &lt;Informer message={message + decor}/&gt;;\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Но в случае когда пропсы представлены множеством значений которые к тому же могут принадлежать к типам определенных разработчиками, то более целесообразно включить в описание типа пропсов компонента-провайдера тип описывающий пропсы компонента которому они предназначаются. Поэтому тип описывающий пропсы необходимо экспортировать. Кроме того чтобы избежать коллизий именнования типов представляющих пропсы их идентификаторы необходимо конкретизировать, то есть давать более уникальные имена. Поэтому принято имени <code>Props</code> добавлять префикс идентичный названию самого компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// file Informer.tsx\n\n/**[0] */           /**[1] */\nexport interface InformerProps {\n    message: string;\n}\n\n/**\n * [0] экспорт типа\n * [1] уточнение идентификатора (имени)\n */\n\nexport default function Informer({message}: InformerProps){\n  return &lt;h1&gt;{message}&lt;/h1&gt;\n}\n\n\n\n// file InformerDecorator.tsx\n                    /**[0] */\nimport Informer, {InformerProps} from &quot;./Informer&quot;;\n\n/**\n * [0] импорти типа пропсов\n */\n\n/**[1] */               /**[2] */                   /**[3] */\nexport interface InformerDecoratorProps extends InformerProps {\n    decor: number;\n    /**[4] */\n}\n\n/**\n * [1] экспорт типа\n * [2] уточнение идентификатора (имени)\n * [3] расширение типа пропсов другого компонента\n * позволяет не рописывать необходимые ему поля [4]\n */\n\n\nexport default function InformerDecorator({decor, message}: InformerDecoratorProps){\n  return &lt;Informer message={message + decor}/&gt;;\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В случаях когда компонент-провайдер нуждается только в части пропсов определенных в типе представляющих их, ненужную часть можно исключить с помощью типа <code>Omit&#x3C;T, K></code> или <code>Exclude&#x3C;T, U></code>.</p><p>Не будет лишним напомнить, что при помощи модификатора <code>readonly</code> не удастся избежать изменений переменных ссылки на которые были получены с помощью механизма деструктуризации.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">export interface InformerProps {\n    /**[0] */\n    readonly message: string;\n};\n\n                                            /**[1] */\nexport default function Informer({message} : Readonly&lt;InformerProps&gt;){\n    message = &#39;new value&#39;; /**[2] */\n\n    return &lt;h1&gt;{message}&lt;/h1&gt;\n}\n\n/**\n * [0] добавление модификатора readonly вручную,\n * а затем ещё тоже самое с помощью тип Readonly&lt;T&gt; [1]\n * и тем не менее переменная message изменяема [2].\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Такое поведение является причиной того что идентификаторы являются определением новой переменной, а переменные не могут иметь модификатор <code>readonly</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                  /**[0] */\nlet o: Readonly&lt;{f: number}&gt; = {f: 0};\no.f = 1; // Error -&gt; [1]\n\nlet {f} = o;\nf = 1; // Ok -&gt; [2]\n\n/**\n * Определение переменной o с типом инлайн интерфейса [0]\n * поля которого модифицированны с помощью типа Readonly&lt;T&gt;.\n * При попытке изменить член o.f с модификатором readonly\n * возникает ошибка [1] -&gt;\n * Cannot assign to &#39;f&#39; because it is a read-only property.\n * Чего не происходит при изменении переменной определенной\n * в процессе деструктуризации.\n * \n * Механизм деструктуризации предполагает создание новой\n * переменной со значением одноименного члена объекта указанного\n * в качестве правого операнда выражения.\n * Выражение let {f} = o; эквивалентно выражению let f = o.f;\n * В этом случае создается новая переменная тип которой устанавливается\n * выводом типов. А вот модификатор readonly не применим к переменным.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>При необходимости декларирования <code>children</code> можно выбрать несколько путей. Первый из них подразумевает использование обобщенного типа <code>PropsWithChildren&#x3C;P></code> ожидающего в качестве аргумента типа тип представляющий пропсы. Данный тип определяет <code>children</code> как необязательное поле с типом <code>ReactNode</code>. При отсутствии продуманного плана на счёт <code>children</code> или необходимости их принадлежности к любому допустимому типу, данный тип будет как нильзя к месту.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                    /**[0] */\nimport React, {PropsWithChildren} from &quot;react&quot;;\n\nexport interface LabelProps {\n\n}\n\n                                                /**[1] */\nexport default function Label({children}: PropsWithChildren&lt;LabelProps&gt;){\n    return (\n        &lt;span&gt;{children}&lt;/span&gt;\n    );\n}\n\n/**\n * [0] импорт типа PropsWithChildren&lt;T&gt;\n * для указания его в аннотации типа параметров [1].\n */\n\n\n&lt;Label&gt;{&quot;label&quot;}&lt;/Label&gt;; // string as children -&gt; Ok [2]\n&lt;Label&gt;{1000}&lt;/Label&gt;; // number as children -&gt; Ok [3]\n&lt;Label&gt;&lt;/Label&gt;; // undefined as chiildren -&gt; Ok [4]\n\n /**\n  * При создании экземпляров компонента Label\n  * допустимо указывать в качестве children\n  * как строку [2], так и числа [3] и кроме\n  * того не указывать значения вовсе [4]\n  */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если логика компонента предолагает обязательную установку <code>children</code> или уточнение типа к которому они принадлежат, то появляется необходимость их непосредственной декларации в типе представляющем пропсы этого компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">/**\n * [0] children определены как \n * обязятельное пренадлежащие к\n * типу string поле.\n */\ninterface LabelProps {\n    children: string; /**[0] */\n}\n\n\nexport default function Label({children}: LabelProps){\n    return (\n        &lt;span&gt;{children}&lt;/span&gt;\n    );\n}\n\n\n&lt;Label&gt;{`label`}&lt;/Label&gt;; // Ok\n&lt;Label&gt;{1000}&lt;/Label&gt;; // Error -&gt; number не совместим со string\n&lt;Label&gt;&lt;/Label&gt;; // Error -&gt; children обязательны</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Может показатся что конкретизация типа <code>children</code> будет полезна при создании собственных <code>ui</code> компонентов. К примеру при создании компонента <code>List</code> отрисовывающего элемент <code>ul</code>, было бы здорого определить <code>children</code> как массив компонентов <code>ListItem</code> отрисовывающих элемент <code>li</code>.</p><p>Для этого понадобится импортировать обощенный тип <code>ReactElement&#x3C;P, T></code> первый параметр типа которого ожидает тип пропсов, а второй строку или конструктор компонента для указания его в качестве типа поля <code>type</code> необходимого для идентификации. По факту тип <code>ReactElement&#x3C;P, T></code> представляет экземпляр любого компонента в системе типов <em>React</em>. После определения компонентов <code>List</code> и <code>ListItem</code>, нам понадобится для первого переопределить поле <code>children</code> указав ему тип <code>ReactElement&#x3C;ListItemProps></code>, что буквально означает экземпляр компонента пропсы которого принадлеат к типу указанному в качестве первого аргумента типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                  /**[0] */\nimport React, { ReactElement, ReactNode } from &quot;react&quot;;\n\n/**\n * [0] импорт типа представляющего\n * экземпляр любого компонента.\n */\n\ninterface ListItemProps {\n    children: ReactNode; /**[1] */\n}\n\n/**\n * [1] для примера определим тип children\n * как ReactNode представляющего любой\n * допустимый тип.\n */\n\n function ListItem({children}: ListItemProps){\n return &lt;li&gt;{children}&lt;/li&gt;;\n }\n\n\n\ninterface ListProps {\n    children: ReactElement&lt;ListItemProps&gt;; /**[2] */\n}\n\n/**\n * [2] при определении children\n * указываем тип ReactElement&lt;ListItemProps&gt;\n * что стоит понимать как - экземпляр компонента\n * пропсы которого совм6естимы с типом ListItemProps.\n */\n\nfunction List({children}: ListProps) {\n    return &lt;ul&gt;{children}&lt;/ul&gt;;\n}\n\n/**[3] */\n&lt;List&gt;\n    &lt;ListItem&gt;first&lt;/ListItem&gt;\n&lt;/List&gt;\n\n/**\n * [3] создаем экземпляр List\n * и указываем ему в качестве children\n * один экземпляр ListItem.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если кажется просто, то не стоит сомневатся, оно так и есть. Совершенно ничего сложного. Единственное стоит уточнить два важных момента. </p><p>Первый момент заключается в том, что конкретизация типа <code>children</code> для <em>React</em> элементов не работает. Проще говоря, если определить новый компонент <code>Label</code> и указать ему в качестве пропсов тип определяющий единственное поле <code>type</code>, то его экземпляр без возникновения ошибки можно будет указать в качестве <code>children</code> компоненту <code>List</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">/**[0] */\ninterface ListItemProps {\n    children: string;\n}\n\n/**\n * [0] оставляем тип пропсов,\n * но для упрощения удаляем компонент\n * нуждающийся в нем.\n */\n\n/**[1] */\ninterface LabelProps {\n    type: &#39;danger&#39; | `error`;\n    children: ReactNode;\n}\n\n/**[1] */\nfunction Label({type, children}: LabelProps){\n    return &lt;span className={type}&gt;{children}&lt;/span&gt;\n}\n\n/**\n * [1] определяем компонент Label\n * и описываем его пропсы.\n */\n\n\n\ninterface ListProps {\n    children: ReactElement&lt;ListItemProps&gt;; /**[2] */\n}\n\n/**\n * Тип children по прежнему указан\n * как ReactElement&lt;ListItemProps&gt;.\n */\n\n// компонент List удален для упрощения\n\n/**[3] */\n&lt;List&gt;\n    &lt;Label type={&#39;danger&#39;}&gt;Hello World!&lt;/Label&gt;\n&lt;/List&gt;\n\n/**\n * [3] несмотря на то что в комопненте List\n * тип children обозначен как ReactElement&lt;ListItemProps&gt;\n * вместо ожидаемого экземпляра без возникновения\n * ошибки устанавливается тип ReactElement&lt;LabelProps&gt;.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Всё дело в том, что экземпляр компонента представляется типом <code>Element</code> из пространнства имен <em>JSX</em>, который является производным от типа <code>ReactElement&#x3C;P, T></code> и при расширении (<code>extends</code>) устанавливает в качестве аргументов типа тип <code>any</code>. Это в свою очередь означает что любые экземпляры компонентов будут совместимы с любыми типами <code>ReactElement&#x3C;P, T></code>, что делает уточнение типа бессмысленным.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">let listItem = &lt;ListItem&gt;first&lt;/ListItem&gt;; // let listItem: JSX.Element\nlet label = &lt;Label type={&#39;danger&#39;}&gt;label&lt;/Label&gt;; // let label: JSX.Element\n\n/**\n * Поскольку оба экземпляра принадлежат\n * к типу JSX.Element который в свою очередь\n * является производным от типа ReactElement&lt;any, any&gt;,\n * то любой экземпляр будет совместим с любым типом ReactElement&lt;P, T&gt;.\n */\n\n let v0: ReactElement&lt;ListItemProps&gt; = label;\n let v1: ReactElement&lt;LabelProps&gt; = listItem;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p> Кроме этого <code>ReactElement&#x3C;P, T></code> совместим не только с экземплярами компонентов, но и <em>React</em> элементов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">let v: ReactElement&lt;ListItemProps&gt; = &lt;span&gt;&lt;/span&gt;; // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Это, как уже было сказанно делает конкретизацию <code>children</code> для экземпляров <em>React</em> компонентов и элементов бессмысленной. Остается надеятся что это исправят.</p><p>Второй момент о котором речь о котором шла чуть ранее состоит в том что при текущей поставноке, в случае необходимости указать в качестве <code>children</code> множество экземпляров <code>ListItem</code> возникнет ошибка.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface ListProps {\n    children: ReactElement&lt;ListItemProps&gt;; /**[0] */\n}\n\n/**[1] */\n&lt;List&gt;\n    &lt;ListItem&gt;first&lt;/ListItem&gt;\n    &lt;ListItem&gt;second&lt;/ListItem&gt;\n&lt;/List&gt;\n\n/**\n * [0] тип указан как единственный\n * экземпляр компонента. поэтому при\n * установке множества экземпляров [1]\n * возникает ошибка.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Для разрешения подобного случая необходимо указать тип <code>children</code> как объединение (<code>Union</code>) определенное типами  представляющих как единственный экземпляр <code>ReactElement&#x3C;ListItemProps></code> так и множество, а если быть конкретнее то массив экземпляров <code>ReactElement&#x3C;ListItemProps>[]</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface ListProps {\n    children: ReactElement&lt;ListItemProps&gt; | ReactElement&lt;ListItemProps&gt;[]; /**[0] */\n}\n\n/**[1] */\n&lt;List&gt;\n    &lt;ListItem&gt;first&lt;/ListItem&gt;\n    &lt;ListItem&gt;second&lt;/ListItem&gt;\n&lt;/List&gt;\n\n/**\n * [0] указание в качестве типа children\n * объединение предполагающее как единственный\n * экземпляр так и множество, ошибка [1] не возникает.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Ввиду того что темы которые так или иначе соприкосаются с первым параметром функционального компонента обозначаемым как пропсы себя исчерпали, настало время рассмотреть его второй, не часто используемый параметр предназначеный для передачи ссылки на текущий компонент которая чаще обозначается как <em>реф</em>. Но поскольку тему связанную с рефами нельзя назвать незначительной, знакомство с ней будет включать множество других сопряженных тем часть из которых будет рассмотрена лишь поверхностно, поскольку детально этому будет уделено время в дальнейшем.</p><p>Начать тему посвященную рефам стоит с напоминания того, что они делятся на два вида. Первый вид предназначен для получения ссылок на <em>React элементы</em>, а второй на <em>React компоненты</em>.\nКроме того для функциональных компонентов существуют уникальные для них механизмы осуществимые с помощью хуков <code>useRef()</code> и <code>useImperativeHandle()</code>, а также вспомошательной функции <code>forwardRef()</code>.</p><p>Представьте сценарий при котором форма должна перейти в начальное состояние путем вызова нативного метода <code>reset()</code> что потребует получения на нее ссылки с помощью объекта рефы создаваемого хуком <code>useRef()</code>.</p><p>Для начала необходимо с помощью универсальной функции <code>useRef()</code> создать объект рефы и присвоить ссылку на него переменной чтобы в дальнейшем передать элементу формы. Сразу стоит обратить внимание что декларации <em>React</em> элементов содержат устаревшие типы в аннотации поля <code>ref</code> что неприменно приведет к возникновению ошибке при установлении объекта рефы. Чтобы этого избежать необходимо явным образом при определении объекта рефы преобразовать его к обобщеному типу <code>RefObject&#x3C;T></code> которому в качестве аргумента типа установить тип нативного элемента, в данном случае <code>HTMLFormElement</code>. Также стоит сделать акцент на том, что необходимо именно преобразование. Указания аннотации типа переменной или передачи типа в качестве аргумента типа хуку не поможет. Более детально поведение хука <code>useState()</code> рассматривается в главе посвященной предопределенным хукам.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React, { useRef, RefObject } from &quot;react&quot;;\n\nfunction Form(){\n                   /**[0]         [1]          [2] */\n    let formRef = useRef() as RefObject&lt;HTMLFormElement&gt;;\n    \n                 /**[3] */\n    return &lt;form ref={formRef}&gt;&lt;/form&gt;\n}\n\n/**\n * Создаваемый хуком объект рефы необходимо преобразовать в обобщенный тип\n * RefObject&lt;T&gt; [1] в качестве аргумента которому требуется указать нативный тип\n * формы [2]. Если не произвести преобразования то в момент установки объекта рефы форме [3]\n * возникнет ошибка, поскольку декларации описывавющие React элементы содержут устаревший\n * тип в аннотации поля ref.\n * \n * БОЛЕЕ ПОДРОБНО В ТЕМЕ ПОСВЯЩЕННОЙ ХУКУ useRef()\n * \n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если появится необходимость возвращения формы в первоначальное состояние извне компонента то можно прибегнуть к механизму получения ссылки на сам компонент или если быть точнее на определяемый им объект выступающий в роли публичного <em>api</em>. Но для того чтобы стало возможным получения ссылки на функциональный компонент его необходимо преобразовать с помощью универсальной функцией <code>forwardRef&#x3C;R, P>()</code> с которой и начнется дальнейшее повествование.</p><p>По факту логика работы универсальной функции <code>forwardRef&#x3C;R, P>(render)</code> заключатеся в проверке единственного параметра на принадлежность к функциональному типу у которой помимо первого параметра представляющего <code>props</code> определен ещё и второй представляющий <code>ref</code>. Данная функция обозначается как <code>render</code> и теоретически её можно считать функциональным компонентом с определением второго параметра предназначенного для установления рефы. В системе типов <em>React</em> функция <code>render</code> принадлежит к обобщенному функциональному типу <code>ForwardRefRenderFunction&#x3C;T, P></code> определяющего два параметра типа, первый из которых представляет тип рефы, а второй пропсов. Первый параметр функции <code>render</code> представляющий пропсы не таит в себе ничего необычного. В отличии от него второй параметр представляющий рефу требует детального рассмотрения поскольку именно с ним связан один неочевидный момент.</p><p>Дело в том что рефы могут быть представлены как экземпляром объекта принадлежащего к типу <code>RefObject&#x3C;T></code> или полностью совместимым с ним <code>MutableRefObject&#x3C;T></code>, так и функцией <code>&#x3C;T>(instance: T) => void</code>. Учитывая этот факт функция <code>render</code> в аннотации типа второго параметра <code>ref</code> просто вынуждена указать это множество представленное типом объединение (<code>Union</code>). Но сложность состоит в том, что определение типа объединение происходит непосредственно в аннотации типа параметра <code>ref</code>. Простыми словами система типов <em>React</em> не предусматрела более удобного и короткого псевдонима типа представляющего рефу определяемую функциональным компонентом.  </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface ForwardRefRenderFunction&lt;T, P = {}&gt; {\n                                       /**                              [0]                              */\n    (props: PropsWithChildren&lt;P&gt;, ref: ((instance: T | null) =&gt; void) | MutableRefObject&lt;T | null&gt; | null): ReactElement | null;\n}\n\n/**\n * [0] тип объединение определенный\n * непосредственно в аннотации типа.\n * Простыми словами он не имеет более\n * удобного короткого псевдонима.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Это означает что функциональный компонент определенный как <em>Function Declaration</em> и указавший принадлежность второго параметра к типу, скажем <code>MutableRefObject&#x3C;T></code> не сможет пройти проверку на совместимость типов в качестве аргумента универсальной функии <code>forwardRef()</code> даже если установить её аругменты типа. И причина тому контрвариантность параметров функции при проверки на совместимость.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                    /**[0]           [1] */\nimport React, { MutableRefObject, forwardRef } from &quot;react&quot;;\n\nexport interface FormProps {}\n\n/**[2] */\nexport interface FormApi {\n    reset: () =&gt; void;\n}\n\n/**\n * [2] объявление типа описывающего доступное\n * api компонента.\n */\n                               /**[3]       [4]         [5] */\nfunction Form(props: FormProps, ref: MutableRefObject&lt;FormApi&gt;) {\n    return null;\n}\n\n        /**[6]          [7]      [8]       [9]     [10] */\nconst FormWithRef = forwardRef&lt;FormApi, FormProps&gt;(Form /**Error */);\n\nexport default FormWithRef; /**[11] */\n\n/**\n * [0] ммпорт обобщенного типа MutableRefObject&lt;T&gt;\n * который будет указан в аннотации типа [4] второго\n * параметра [3] функионального комопнента предаврительно\n * получив в качестве аргумента типа тип нативного dom\n * элемента HTMLDivElement [5].\n * \n * Несмотря на все принятые меры по типизации сигнатуры функционального\n * компонента Form избежать возникновения ошибки [10] при проверке на совместимость\n * в момент передачи в качестве аргумента универсальной функции forwardRef [7] не получится\n * даже при конкретизации с помощью аргументов функционального типа [8][9].\n * \n * [11] для экспорта функционального компонента определяющего второй параметр необходимо\n * сохранить результат выполнения функции forwardRef [6].\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Разрешить данную ситуацию можно несколькими способами. Первый заключается в явном преобразовании типа функционального компонента к типу <code>ForwardRefRenderFunction&#x3C;T, P></code> которому в качестве аргументов типа требуется указать необходимые типы. При этом отпадает нужда в указании аругументов типа непосредственно самой универсальной функции <code>forwardRef&#x3C;T, P>()</code>;</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                                                     /**[0] */\nimport React, { MutableRefObject, forwardRef, ForwardRefRenderFunction } from &quot;react&quot;;\n\nexport interface FormProps {}\nexport interface FormApi {\n    reset: () =&gt; void;\n}\n\nfunction Form(props: FormProps, ref: MutableRefObject&lt;FormApi&gt;) {\n    return null;\n}\n\n                        /**[6]                          [7]       [8]        [9] */\nconst FormWithRef = forwardRef(Form as ForwardRefRenderFunction&lt;FormApi, FormProps&gt;);\n\nexport default FormWithRef;\n\n/**\n * [0] импорт обобщенного функционального типа ForwardRefRenderFunction&lt;T, P&gt;\n * к которому тип Form [7] будет преобразован с помощью оператора as, для\n * чего потребуентся указать необходимые аргументы типа [8] [9]. При этом отпадает\n * потребность в установке аргументов непосредственно универсальной функции [6]\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Следующий способ заключается в получении типа представляющего рефу непосредственно из самого функционального типа <code>ForwardRefRenderFunction&#x3C;T, P></code>. Для необходимо указать в аннотации второго параметра функционального компонента обобщенный тип взятого у второго параметра функционального типа <code>ForwardRefRenderFunction&#x3C;T, P></code> при помощи типа <code>Parameters&#x3C;T></code> предназначенного для получения массива с типами соответствующих параметрам функции. Поскольку интересующий нас тип принадлежит второму параметру, то он будет доступен как элемент под индексом один результатирующего массива. Кроме того в указании аргументов типа универсальной функции <code>forwardRef&#x3C;T, P>()</code> нет необходимости поскольку выводу типов достаточно описания сигнатуры функционального компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React, { forwardRef, ForwardRefRenderFunction } from &quot;react&quot;;\n\nexport interface FormProps {}\nexport interface FormApi {\n    reset: () =&gt; void;\n}\n\n  /**[0][1]       [2]             [3]            [4] [5] */\ntype Ref&lt;T&gt; = Parameters&lt;ForwardRefRenderFunction&lt;T&gt;&gt;[1];\n\n                                  /**[6]   [7] */\nfunction Form(props: FormProps, ref: Ref&lt;FormApi&gt;) {\n    return null;\n}\n\n                        /**[8] */\nconst FormWithRef = forwardRef(Form);\n\nexport default FormWithRef;\n\n/**\n * При помощи типа Parameters&lt;T&gt; [2] получаем массив элементы которого\n * принадлежат к типам параметров функции представляемой типом\n * ForwardRefRenderFunction&lt;T, P&gt; [3] которому в качестве первого аргумента\n * типа [4] устанавливаем параметр обобщенного псевдонима [1]. Таким образом\n * Ref&lt;T&gt; ссылается на первый элемент массива [5] содержащего тип указанный в аннотации\n * второго параметра (ref). Определенный псевдоним указываем в аннотации\n * второго параметра функционального компонента [6] установив в качестве аргумента\n * типа тип нативного dom элемента [7]. При таком сценарии нет необходимости \n * конкретизировать типы при помощи аргументов типа универсальной функции\n * forwardRef&lt;T, P&gt;() [8]. \n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Последнее на что стоит обратить внимание это обобщенный тип <code>ForwardRefExoticComponent&#x3C;P></code> к которому принадлежит значение возвращаемое из универсальной функции <code>forwardRef&#x3C;T, P>()</code> и указывать который в явной форме нет никакой необходимости.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                                                              /**[0] */\nimport React, { forwardRef, ForwardRefRenderFunction, ForwardRefExoticComponent } from &quot;react&quot;;\n\n// ...\n\n                            /**[1]                [2] */\nconst FormWithRef: ForwardRefExoticComponent&lt;FormProps&gt; = forwardRef(Form);\n\nexport default FormWithRef;\n\n/**\n * [0] импорт обобщенного типа ForwardRefExoticComponent&lt;P&gt;\n * который в качестве аргумента типа ожидает тип представляющий пропсы того\n * компонента [2] в аннотации типа которого указан [1]. СТоит заметить что\n * указан он исключительно в образовательных целях.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>После того как функциональный компонент получит рефу ему необходимо присвоить ей значение выступающее в качестве открытого <em>api</em>. Для этого необъодимо прибегнуть к помощи хука <code>useImperativeHandle&#x3C;T, R>(ref: Ref&#x3C;T>, apiFactory() => R): void</code> подробное рассмотрение которого можно найти в теме посвященной предопределенным хукам. </p><p>Для того чтобы с помощью хука <code>useImperativeHandle()</code> ассоциировать рефу с открытым <em>api</em> комопнента необходимо в качестве первого аргумента передать рефу определенную вторым параметром функционального компонента. Полю определенного в рефе ожидаемой в качестве первого параметра хука будет присвоено значение возвращаемое из функции ожидаемой в качестве второго параметра. Процесс переинициализации будет выполнятся всекий раз при изменении элементов массива ожжидаемого в качестве третьего параметра данного хука. Также необходимо уточнить что рефа создаваемая с помощью хука <code>useRef()</code> и предназначеная для ассоцииации  с функциональным компонентом также нуждается в явном преобразовании к обобщенному типу <code>MatableRefObject&#x3C;T></code> которому в качестве единственного аргумента типа будет установлен тип представляющий открытое <em>api</em> комопнента. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React, { forwardRef, ForwardRefRenderFunction, RefObject, useRef, useImperativeHandle, MutableRefObject } from &quot;react&quot;;\n\ninterface FormProps {}\ninterface FormApi {\n    reset: () =&gt; void;\n}\n\ntype Ref&lt;T&gt; = Parameters&lt;ForwardRefRenderFunction&lt;T&gt;&gt;[1];\n\nfunction Form(props: FormProps, ref: Ref&lt;FormApi&gt;) {\n                    /**[0] */\n    let formRef = useRef() as RefObject&lt;HTMLFormElement&gt;;\n\n        /**[1]          [2]     [3] */\n    useImperativeHandle(ref, () =&gt; ({\n        reset: () =&gt; formRef.current?.reset()\n    }), [] /**[4] */);\n\n\n    return &lt;form ref={formRef}&gt;&lt;/form&gt;;\n}\n\n/**\n * [0] не забываем о необходимости явного преобразования.\n * Хук useImperativeHandle жидает в качестве первого параметра\n * ссылку [1], в качестве второго фабричную функцию [3] которая\n * будет переопредлелять объект api каждый раз при изменении \n * элементов массива ожидаемого в качестве третьего параметра [4].\n *  \n */\n\nconst FormWithRef = forwardRef(Form);\n\n\nconst App = () =&gt; {\n                       /**[5]         [6]        [7] */\n    let formRef = useRef() as MutableRefObject&lt;FormApi&gt;;\n    \n    /**[8] */\n    formRef.current?.reset();\n\n                /**[9] */\n    return &lt;FormWithRef ref={formRef}/&gt;;\n}\n\n/**\n * Необходимо помнить что ссылка предназначенная\n * для ассоцииации с функциональным компонентом\n * также требует явного преобразование [5] к обобщенному\n * типу MutableRefObject&lt;T&gt; [6] которому в качестве аргумента\n * типа необходимо установить тип представляющий открытое api\n * компонента [7]. И после создания экземпляра компонента определенного\n * с помощью функции forwardRef [9] можно использовать его api через объект\n * рефы [8].\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В связи с тем что функциональный компонент может определять только два параметра пора перейти к рассмотрению следующего звена его сигнатуры. Или если быть точнее аннотации типа возвращаемого им значения. Возвратимся к первоначальному модифицированному с учетом пропсов примеру функционального компонента у которого тип возвращаемого значения не указан явно. И сразу сделать жирный акцент на том, что в большинстве случаев такой подход является более предпочтительным.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React from &quot;react&quot;;\n\nexport interface TimerProps {}\n\nexport default function Timer(props: TimerProps) /**[0] */ {\n    return &lt;div&gt;Is Timer!&lt;/div&gt;;\n}\n\n\n/**\n * [0] отсутствие явного указания типа\n * возвращаемого типа, что для большинства\n * случаев является ппредпочтительным.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>И дело не в том чтобы как можно больше делегировать работы выводу типов экономя тем самым драгоценное время, а в том что система типов <em>React</em> устанавливаемая из репозиториев <code>@types</code> не имеет достаточно высокого уровня типобезопастности. Поскольку это очень щекотливая тема её освещение стоит начать с самого начала, а именно с перечисления типов к которым может принадлежать возвращаемое значение.</p><p>И так, любое допустимое возвращаемое компонентом значение в системе типов <em>React</em> может быть представленно типом <code>ReactNode</code> являющимся объединением (<code>Union</code>) определяемого такими типами как <code>ReactChild | ReactFragment | ReactPortal | boolean | null | undefined</code>. Тип <code>ReactChild</code> также представляет из себя объединение таких типов как <code>ReactElement&#x3C;Props, Type> | ReactText</code>. Первый, как уже было рассмотренно ранее, представляет экземпляр любого компонента и элемента <em>React</em>, а второй объединение <code>string | number</code>. <code>ReactFragment</code> также представляет объединение для <code>{} | ReactNodeArray</code>. Не сложно догадатся что <code>ReactNodeArray</code> это абстракция над <code>Array&#x3C;ReactNode></code>. И оставшийся тип <code>ReactPortal</code> является производным от типа <code>ReactElement</code>. Это может казатся очень запутанным и более того разбиратся в этом прямо сейчас нет нужды, поскольку совсем скоро станет ясно в чем кроется подвох причиной которого являются два из перечисленных типа.</p><p>Первый тип вносящий смуту, это ранее рассмотренный <code>ReactElement&#x3C;P, T></code> и всё неожиданное поведение которое с ним связанно. Вторым типом вносящий неразбериху стал <code>ReactFragment</code> поскольку определяющий его пустой объектный тип <code>{}</code> совместим с любым экземпляром объектного типа. По факту при использовании в качестве типа возвращаемого значения <code>ReactFragment</code> или <code>ReactNode</code> ошибки не возникнет даже если оно будет экземпляром <code>Promise</code> или чего-то ещё. И хотя отсутствие ошибки на этапе компиляции не означает что её получится избежать во время выполнения, сам сценарий с возвратом ошибочного значения может показатся чересчур надуманным. С какой-то долей вероятности можно с этим согласится, но поскольку идеалогия <em>TypeScript</em> подразумевает выявление проблем в программах до их запуска, об этом стоило хотя бы упомянуть.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React, { ReactFragment, ReactNode } from &quot;react&quot;;\n\n\nfunction A(): ReactFragment {\n    return Promise.resolve(0); /**[0] */\n}\nfunction B(): ReactNode {\n    return Promise.resolve(0); /**[0] */\n}\n\n/**\n * [0] Ok на этапе компиляции и\n * Error во время выполнения.\n */\n\n\n/**[1] */\nclass T {\n    constructor(readonly p: number){}\n}\n\nfunction C(): ReactFragment {\n    return new T(0); /**[2] */\n}\nfunction D(): ReactNode {\n    return new T(0); /**[2] */\n}\n\n/**\n * [1] определение некоторого класса.\n * [2] Ok на этапе компиляции и\n * Error во время выполнения.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Из всего этого следует что прибегать к аннотации типа возвращаемого значения стоит только в случаях когда оно принадлежит к <code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code> или массиву элементы которого принадлежат к оному из четырех перечисленных типов. Да и то только тогда, когда в этом есть острая необходимость. В остальных случаях целесообразней возложить эту работу на вывод типов, для которого это обычное дело.</p><p>Последнее что осталось без внимание, это событийный механизм или если быть точнее определение слушателей событий. Для этого в системе типов <em>React</em> определен специальный обобщенный тип <code>ReactEventHandler&#x3C;T></code> ожидающий в качестве аргумента типа тип представляющий нативный <em>dom элемент</em> которому будет установлен текущий слушатель событий. </p><p>Представим сценарий в котором по нажатию на кнопку с типом <code>submit</code> необходимо вернуть значения элементов формы в первоначальные. Для этого потребуется подписать элемент формы на событие <code>submit</code> и по его возникновению вызвать у нативного элемента формы, ссылка на которую доступна через свойство событийного объекта <code>target</code>, метод  <code>reset</code>.</p><p>Первым делом реализация подобного сценария потребует импорта обобщенного типа <code>ReactEventHandler&#x3C;T></code>, который в качестве аргумента типа получит тип нативного <em>dom элемента</em> <code>HTMLFormElement</code>, после чего будет указан в аннотации слушателя событий <code>form_submitHandler</code>. Выбор типа нативного <em>dom элемента</em>, в данном случае <code>HTMLFormElement</code>, обучлавливается типом элемента которому устанавливается слушатель событий, в данном случае <code>&#x3C;form></code>. </p><p>Стоит также обратить внимание что единственный параметр слушателя событий в аннотации типа не нуждается, поскольку вывод типов операется на обобщенный тип <code>ReactEvenHandler&#x3C;T></code>.</p><p>По возникновению события первым делом необходимо предотвратить поведение по умолчанию чтобы избежать перезагрузки вкладки браузера. Поскольку ссылка на нативную форму доступна через определенное в объекте события свойство <code>target</code>, которое принадлежит к типу <code>EventTarget</code>, то перед присвоением её переменной <code>form</code> появляется необходимость в приведении к типу <code>HTMLFormElement</code> с помощью оператора <code>as</code>. После это можно вызывать нативный метод <code>reset</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                    /**[0] */\nimport React, {ReactEventHandler} from &quot;react&quot;;\n\nfunction Form(){\n            /**[1]                 [2]              [3]           [4] */\n    const form_submitHandler: ReactEventHandler&lt;HTMLFormElement&gt; = event =&gt; {\n        event.preventDefault(); /**[5] */\n\n        /**  [6]        [7]              [8] */\n        let form = event.target as HTMLFormElement;\n        form.reset(); /**[9] */\n    };\n\n\n    return (\n                            /**[10] */\n        &lt;form onSubmit={form_submitHandler}&gt;\n            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n}\n\n/**\n * [0] импорт обобщенного функционального типа\n * которому установив в качестве аргумента типа\n * тип нативного элемента HTMLFormElement [3]\n * использовали в аннотации типа [2] переменной\n * form_su0bmitHandler [1], которой в качестве\n * значения присвоили функцию слушатель события\n * единственный параметр которой не нуждается в\n * явной аннотации типа [4], поскольку вывод типов\n * операется на тип ReactEventHandler&lt;T&gt;.\n * \n * При возникновении события первым делом происходит\n * предотвращение поведения по умолчанию чтобы избежать\n * перезагрузки вкладки браузера [5]. Затем создается\n * переменная form [6] которой присваивается ссылка на\n * нативный dom элемент доступный через свойство определенное\n * в объекте события target [7] которое при помощи оператора \n * as приведено к нужному типу нативного dom элемента HTMLFormElement [8].\n * \n * На следующем шаге вызывается нативный метод сброса значений формы reset [9]\n * \n * [10] установка слушателя событий React элементу form.\n * \n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Несмотря на то что такой способ типизирования слушателей событий является предпочтительным также не будет лишним рассмотреть и другой имеющийся вариант состоящий в описании непосредственно сигнатуры функции.</p><p>Для этого, в нашем конкретном случае, необходимо импортировать обобщенный тип <code>FormEvent&#x3C;T></code>, которому перед размещением в аннотации единственного параметра слушателя события необходимо в качестве аргумента события указать тип нативного <em>dom элемента</em> <code>HTMLFormElement</code>. Также стоит напомнить что в аннотации возвращаемого из слушателя события значения нет необходимости. Подобную рутинную работу необходимо делигировать выводу типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                /**[0] */\nimport React, {FormEvent} from &quot;react&quot;;\n\nfunction Form(){\n                              /**[1]      [2]           [3]          [4] */\n    const form_submitHandler = (event: FormEvent&lt;HTMLFormElement&gt;): void =&gt; {\n\n    }\n\n\n    return (\n        &lt;form onSubmit={form_submitHandler}&gt;\n            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n}\n\n/**\n * [0] импорт обобщенного типа FormEvent&lt;T&gt;\n * которому перед добавлением в аннотацию типа [2]\n * единственного параметра слушателя события [1] \n * необходимо установить в качестве аргумента типа\n * тип нативного dom элемента HTMLFormElement [3].\n * Указании типа к которому принадлежит возвращаемое\n * из слушателя события значения было указанно лишь\n * для того чтобы напомнить об отсутствии в этом необходимости.\n * Подобную работу нужно делегировать выводу типов.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Работа непосредственно с формой обусловила выбор более конкретного типа события каковым в данном примере стал обобщенный тип <code>FormEvent&#x3C;T></code>. При других условиях потребуются другие событийные типы. Кроме того, всегда можно сделать выбор в пользу базового для всех событийных типов <code></code>SyntheticEvent<T>` который в качестве аргумента типа ожидает тип нативного <em>dom элемента</em>.</p><p>Кроме это функциональным компонентам доступно мемоизация слушателей событий при помощи универсального хука <code>useCallback&#x3C;T>()</code>.\nДля этого понадобится импортировать универсальную функцию определяющую два обязательных параметра. В качестве первого параметра ожидается функция чье описание устанавливается в качестве аргумента функционального типа. Второй параметр принадлежит к типу массива изменение элементов которого приводит к переинициализации функции переданной в качестве первого параметра данного хука. Поскольку в качестве аргумента функционального тпа ожидается тип описывающий первый параметр хука, то нет необходимости в аннотациях типа её параметров. Или в данном случае её единственного праметра представляющего объект события. В остальном реализация ничем не отличается от предыдущего примера, поэтому повторяющийся код будет исключён.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">                /**[0] */\nimport React, {useCallback, ReactEventHandler} from &quot;react&quot;;\n\nfunction Form(){\n                                 /**[1]                    [2]                       [3]*/\n    const form_submitHandler = useCallback&lt;ReactEventHandler&lt;HTMLFormElement&gt;&gt;(event =&gt; {\n\n    }, [] /**[4] */ );\n\n\n    return (\n        &lt;form onSubmit={form_submitHandler}&gt;\n            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;\n        &lt;/form&gt;\n    );\n}\n\n/**\n * [0] импорт универсальной функции useCallback&lt;T&gt;()\n * принимающей в качестве первого обязательного параметра\n * функцию [3], описание которой устанавливается в качестве\n * аргумента функционального типа [1]. D качестве второго\n * обязательного параметра ожидается массив [4] со значениями\n * изменение которых приводит переинициализации функции переданной\n * в качестве первого аргумента.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>На этом рассмотрение типизирования функционального компонента определенного как <em>Function Declaration</em> завершено. И поскольку тема получилась довольно не маленькая исключим затягивание и перейдем к рассмотрению следующего вида функциональных компонентов.</p></section>\n<section class=\"content__section\" id=\"opredelenie_komponenta_kak_function_expression\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"opredelenie komponenta kak function expression\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Определение компонента как Function Expression</span></h2><p>Поскольку самое необходимое относящиеся ко всем видам <em>React</em> компонентов было рассмотренно в предыдущей теме, в этой и последующих повествование будет сосредоточено исключительно на различиях.</p><p>Для определения функционального компонента как <em>Function Expression</em> декларация типов <em>React</em> предусмотривает вспомогательный обобщенный тип <code>FC&#x3C;Props></code> чей идентификатор (имя) является сокращением от <em>Function Component</em>, а аргумент типа ожидающий тип представляющий пропсы явялется необязательным. Поскольку вывод типов ориентируется на тип пропсов указанный или присущий по умолчанию в качестве аргумента типа, то в аннотировании первого параметра функционального компонента нет надобности. Помимо этого типо пропсов по умолчанию описывает необязательное поле <code>children</code> принадлежащего к типу <code>ReactNode</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">             /**[0] */\nimport React , {FC} from &quot;react&quot;;\n\n          /**[1]       [2] */\nconst Timer: FC = ({children}) =&gt; &lt;div&gt;Is Timer!&lt;/div&gt;;\n\n/**\n * [0] импорт обобщенного типа FC&lt;P&gt;\n * который указан в аннотации без\n * установки аргумента типа [1] и\n * несмотря на это ошибки при деструктуризации\n * поля children не возникает даже без аннотации\n * типа первого параметра [2]\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если тип пропсов указан в качестве аругмента типа <code>FC&#x3C;P></code> и при этом не описывает поле <code>children</code>, то оно всен равно будет определенно в объекте пропсов доступного в качестве первого параметра функционального компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React , {FC} from &quot;react&quot;;\n\nexport interface TimerProps {\n    duration: number;\n    /**[0] */\n}\n                 /**[1]                     [3]*/\nconst Timer: FC&lt;TimerProps&gt; = ({duration, children}) =&gt; &lt;div&gt;Is Timer!&lt;/div&gt;;\n\n\nexport default Timer;\n\n/**\n * [0] несмотря на то что тип представляющий\n * пропсы и указанный в качестве аргумента\n * типа FC&lt;P&gt; [1] не описывает поле children\n * при их деструктуризации ошибки не возникает [3]\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В отсльном все что было рассмотренно в предыдущей теме относительно пропсов и <code>children</code> идентично и для данного способа типизирования функциональных компонентов.</p><p>При возникновении необходимости в определении второго параметра функционального компонента придется самостоятельно указывать аннотацию типа, поскольку по каким-то причинам обобщенный тип <code>FC&#x3C;P></code> этого не предусматривает.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React, { FC } from &quot;react&quot;;\n\nexport interface TimerProps {}\n\n\n                             /**[1]   [2] */\nconst Timer: FC&lt;TimerProps&gt; = (props, ref) =&gt; &lt;div&gt;Is Timer!&lt;/div&gt;;\n\n/**\n * Первый параметр [0] выводится как\n * PropsWithChildren&lt;TimerProps&gt;, а\n * второй [2] как any, поскольку обобщенный\n * тип FC&lt;P&gt; не предусматривает его наличие.\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В остальном все рассмотренное относительно рефов в теме посвященной функциональным компонентам определенным как <em>Function Declaration</em> верно и для текущего вида определения с единственным исключением. Поскольку в отдличии от определений <em>Function Declaration</em> определния <em>Function Expression</em> могут содержать аннотацию, то при необходимости во втором параметре можно отказаться от типа <code>FC&#x3C;P></code> в пользу ранее рассмотренного типа <code>ForwardRefRenderFunction&#x3C;T, P></code>. При указании данного типа в аннотации функционального компонента пропадает необходимость как а явном аннотировании типов его параметров, так и в указании аргументов типа универсальной функции <code>forwardRef&#x3C;T, P>()</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React, { FC, forwardRef, ForwardRefRenderFunction } from &quot;react&quot;;\n\nexport interface TimerProps {}\n\n\n                    /**[1] */\nconst Timer: ForwardRefRenderFunction&lt;HTMLDivElement, TimerProps&gt; = (props, ref) =&gt; &lt;div&gt;Is Timer!&lt;/div&gt;;\n\n\n                        /**[2] */\nconst TimerWithRef = forwardRef(Timer);\n\nexport default TimerWithRef;\n\n/**\n * [0] импорт типа для указания его в аннотации\n * функционального компонента [1] определяющего второй\n * параметр ref. После этого нет необходимости в явной\n * аннотации типов как обоих параметров функционального\n * компонента, так и универсальной функции forwardRef&lt;T, P&gt;().\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Важной особенностью использования обобщенного типа <code>FC&#x3C;P></code> заключается в том, что он помимо типа представляющего пропсы, также содержит описание типа возвращаемого функцией значения. Вроде бы так и должно быть, но нюанс заключается в том, что возвращаемое значение обязательно должно принадлежать к типу совместимому с <code>ReactElement&#x3C;P, T></code>. Простыми словами на этапе компиляции возникнет ошибка если функциональный компонент определенный как <em>Fuction Expression</em> будет возвращать значение принадлежащие к типам <code>number</code>, <code>string</code>, <code>boolean</code> или абсолютно любому массиву.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React , {FC} from &quot;react&quot;;\n\nconst A: FC = () =&gt; 0123; // Error\nconst B: FC = () =&gt; &quot;0123&quot;; // Error\nconst C: FC = () =&gt; true; // Error\nconst D: FC = () =&gt; []; // Error\n\nconst E: FC = () =&gt; &lt;div&gt;&lt;/div&gt;; // Ok\nconst F: FC = () =&gt; &lt;E/&gt;; // Ok\nconst G: FC = () =&gt; &lt;&gt;&lt;/&gt;; // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p> Поэтому в случаях когда функционеальный компонент определен как <em>Function Expression</em> и при возвращаемое им значение должно принадлежать к типам не совместимым с <code>ReactElement&#x3C;P, T></code> необходимо самостоятельно описывать его сигнатуру. Что не представляет никакого труда.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">import React ,{MutableRefObject} from &quot;react&quot;;\n\nexport interface TimerProps {}\n\nconst Timer = (props: TimerProps, ref: MutableRefObject&lt;HTMLDivElement&gt;) =&gt; 123;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если в подобном определении функциональных компонентов существует частая потребность будет целесооббразней определить собственный тип подробно описывающий сигнатуру функции.</p><p>Для этого потребуется определеить обобщенный тип с двумя необязательными параметрами. Первый необязательный параметр представляющий тип пропсов должен расширять и к тому же указывать в качестве типа по умолчанию тип <code>object</code>. ВТорой необязательный параметр типа должен проделывать тоже что и первый для типа представляющего базовый нативный тип <em>dom элемента</em> <code>HTMLElement</code>.</p><p>Чтобы не заморачиватся в определении <code>children</code> указываем принадлежность первого параметра функции к уже знакомому обобщеному типу <code>PropsWithChildren&#x3C;P></code> которому в качестве аргумента типа устанавливаем первый параметр типа <code>P</code>. Второму необязательному параметру функции указываем принадлежность к обобщенному типу <code>MutableRefObject&#x3C;E></code> в качестве аргмента типа которому устанавливаем второй параметр типа <code>E</code>. Осталось лишь указать принадлежность возвращаемого функцией значения к типу <code>ReactNode</code> и тип <code>CFC&#x3C;P, E></code> что является сокращением от <em>Custom Functional Component</em> готов к тому чтобы сэкономить время и нервы разработчика.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// file CFC.ts\n\nimport React ,{MutableRefObject, ReactNode, PropsWithChildren} from &quot;react&quot;;\n\n         /**[0][1]         [2]     [3][4]           [5]            [6]                       [7]                      [8]             [9]*/\nexport type CFC&lt;P extends object = object, E extends HTMLElement = HTMLElement&gt; = (props: PropsWithChildren&lt;P&gt;, ref?: MutableRefObject&lt;E&gt;) =&gt; ReactNode;\n\n/**\n * [0] определяем обобщенный тип CustomDunctionComponent\n * или сокращенно CFC первый необязательный параметр представляющего\n * пропсы которого [1] расширяет [2] и устанавливает по умолчанию [3]\n * тип object. Второй необязательный параметр пердставляющий тип нативного\n * dom элемента [4] расширяет [5] и устанавливает по умолчанию [6] тип HTMLElement.\n * \n * [7] устанавливаем принадлежность первого параметра функционального типа к\n * обобщенному типу PropsWithChildren&lt;P&gt; которому в качестве аргумента типа передаем первый\n * параметр типа. \n * \n * [8] определяем принадлежность второго необязательного параметра к обобщенному типу\n * MutableRefObject&lt;E&gt; которому в качестве аргумента типа устанавливаем второй параметр типа.\n * \n * [9] тип возвращаемого значения определяем как ReactNode.\n *  \n */\n\n\n// file Timer.tsx\nimport React from &quot;react&quot;;\nimport {CFC} from &quot;./CFC&quot;; /**[0] */\n\n\nexport interface TimerProps {}\n\n          /**[1]    [2]           [3]            [4]   [5]     [6]*/\nconst Timer: CFC&lt;TimerProps, HTMLDivElement&gt; = (props, ref) =&gt; 123;\n\n/**\n * [0] импорт CustomFunctionCOmponent для\n * указания его в качестве типа функционального\n * компонента определенного как Function Expression [1].\n * В качестве первого параметра типа устанавливается тип\n * представляющий пропсы [2], а в качестве второго тип нативного\n * dom элемента с которым будет ассоциирован объект реф [3].\n * При таком подходе отпадает необходимость в явном указании аннотации\n * типов как пропсов [4], так и рефы [5]. Кроме того возвращаемое значение\n * может принадлежать к любому типу совместимому с типом ReactNode [6]\n */</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>На этом тема касающаяся функциональных компонентов себя полностью исчерпала, поэтому без лишних слов будет продвигатся дальше к следующей теме посвященной классовым компонентам.</p></section>","commitInfoAll":[{"committedDate":"2020-09-08T11:53:53Z","message":"book(технические изменения (link, md, т.п.)): change code wrapper\n\nchange code wrapper from ~ to ` and from typescript to ts","messageHeadline":"book(технические изменения (link, md, т.п.)): change code wrapper","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars3.githubusercontent.com/u/31518738?v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/049\\.\\(React\\) Функциональные компоненты/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"chto takoe i dlya chego nujen typescript","sections":[{"name":"Что такое TypeScript","path":"chto takoe typescript"},{"name":"История TypeScript","path":"istoriya typescript"},{"name":"Для чего нужен TypeScript","path":"dlya chego nujen typescript"},{"name":"Зачем разработчику TypeScript","path":"zachem razrabotchiku typescript"}]},{"name":"Вступление","path":"vstuplenie","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"sistema tipov, tip dannyh, znachimye i ssylochnye tipy","sections":[{"name":"Система Типов","path":"sistema tipov"},{"name":"Тип данных (тип)","path":"tip dannyh (tip)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"tip dannyh, peredaushchiisya po znacheniu (primitivnyi tip)"},{"name":"Тип данных, передающийся по ссылке","path":"tip dannyh, peredaushchiisya po ssylke"}]},{"name":"Связывание, типизация, вывод типов","path":"svyazyvanie, tipizaciya, vyvod tipov","sections":[{"name":"Обработка кода компилятором","path":"obrabotka koda kompilyatorom"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"leksicheskii analiz (tokenizaciya - tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"sintaksicheskii analiz (razbor - parsing)"},{"name":"Семантический анализ","path":"semanticheskii analiz"},{"name":"Связывание (Binding)","path":"svyazyvanie (binding)"},{"name":"Типизация","path":"tipizaciya"},{"name":"Вывод Типов (type inference)","path":"vyvod tipov (type inference)"}]},{"name":"Преобразование типов","path":"preobrazovanie tipov","sections":[{"name":"Неявные Преобразования","path":"neyavnye preobrazovaniya"},{"name":"Явные Преобразования","path":"yavnye preobrazovaniya"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"tipizirovannye i netipizirovannye yazyki programmirovaniya","sections":[{"name":"Нетипизированные языки","path":"netipizirovannye yazyki"},{"name":"Типизированные языки","path":"tipizirovannye yazyki"}]},{"name":"Статическая и динамическая типизация","path":"staticheskaya i dinamicheskaya tipizaciya","sections":[{"name":"Статическая типизация (Static Typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"dinamicheskaya tipizaciya (dynamic typing)"}]},{"name":"Сильная и слабая типизация","path":"silnaya i slabaya tipizaciya","sections":[{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Слабая типизация (weakly typed)","path":"slabaya tipizaciya (weakly typed)"}]},{"name":"Явная и неявная типизация","path":"yavnaya i neyavnaya tipizaciya","sections":[{"name":"Явная типизация (explicit typing)","path":"yavnaya tipizaciya (explicit typing)"},{"name":"Неявная типизация (implicit typing)","path":"neyavnaya tipizaciya (implicit typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"sovmestimost tipov na osnove vida tipizacii","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"sovmestimost tipov (types compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"nominativnaya tipizaciya (nominative typing)"},{"name":"Структурная Типизация (structural typing)","path":"strukturnaya tipizaciya (structural typing)"},{"name":"Утиная Типизация (Duck typing)","path":"utinaya tipizaciya (duck typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"sovmestimost tipov na osnove variantnosti","sections":[{"name":"Вариантность","path":"variantnost"},{"name":"Иерархия наследования","path":"ierarhiya nasledovaniya"},{"name":"Ковариантность","path":"kovariantnost"},{"name":"Контравариантность","path":"kontravariantnost"},{"name":"Инвариантность","path":"invariantnost"},{"name":"Бивариантность","path":"bivariantnost"}]},{"name":"Аннотация Типов","path":"annotaciya tipov","sections":[{"name":"Аннотация Типов - общее","path":"annotaciya tipov - obshchee"},{"name":"Аннотация типа","path":"annotaciya tipa"},{"name":"Синтаксические конструкции var, let, const","path":"sintaksicheskie konstrukcii var, let, const"},{"name":"Функции (function)","path":"funkcii (function)"},{"name":"Стрелочные Функции (arrow function)","path":"strelochnye funkcii (arrow function)"},{"name":"Классы (class)","path":"klassy (class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"sravnenie sintaksisa typescript i javascript"},{"name":"Итог","path":"itog"}]},{"name":"Базовый Тип Any","path":"bazovyi tip any","sections":[{"name":"Any (any) произвольный тип","path":"any (any) proizvolnyi tip"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"primitivnye tipy number, string, boolean, symbol, bigint","sections":[{"name":"Важно","path":"vajno"},{"name":"Number (number) примитивный числовой тип","path":"number (number) primitivnyi chislovoi tip"},{"name":"String (string) примитивный строковый тип","path":"string (string) primitivnyi strokovyi tip"},{"name":"Boolean (boolean) примитивный логический тип","path":"boolean (boolean) primitivnyi logicheskii tip"},{"name":"Symbol (symbol) примитивный символьный тип","path":"symbol (symbol) primitivnyi simvolnyi tip"},{"name":"BigInt (bigint) примитивный числовой тип","path":"bigint (bigint) primitivnyi chislovoi tip"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"primitivnye tipy null, undefined, void, never, unknown","sections":[{"name":"Важно","path":"vajno"},{"name":"Null (null) примитивный null тип","path":"null (null) primitivnyi null tip"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"undefined (undefined) primitivnyi neopredelennyi tip"},{"name":"Void (void) отсутствие конкретного типа","path":"void (void) otsutstvie konkretnogo tipa"},{"name":"Never (never) примитивный тип","path":"never (never) primitivnyi tip"},{"name":"Unknown (unknown)","path":"unknown (unknown)"}]},{"name":"Примитивный Тип Enum","path":"primitivnyi tip enum","sections":[{"name":"Примитивный Тип Enum","path":"primitivnyi tip enum"},{"name":"Enum (enum) примитивный перечисляемый тип","path":"enum (enum) primitivnyi perechislyaemyi tip"},{"name":"Перечисления с числовым значением","path":"perechisleniya s chislovym znacheniem"},{"name":"Перечисления со строковым значением","path":"perechisleniya so strokovym znacheniem"},{"name":"Смешанное перечисление (mixed enum)","path":"smeshannoe perechislenie (mixed enum)"},{"name":"Перечисление в качестве типа данных","path":"perechislenie v kachestve tipa dannyh"},{"name":"Перечисление const с числовым и строковым значением","path":"perechislenie const s chislovym i strokovym znacheniem"},{"name":"Итог","path":"itog"}]},{"name":"Типы - Union, Intersection","path":"tipy - union, intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"tip obedinenie (union types)"},{"name":"Тип Пересечение (Intersection Type)","path":"tip peresechenie (intersection type)"},{"name":"Итоги","path":"itogi"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"type queries (zaprosy tipa), alias (psevdonimy tipa)","sections":[{"name":"Запросы Типа (Type Queries)","path":"zaprosy tipa (type queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"psevdonimy tipov (type aliases)"},{"name":"Итоги","path":"itogi"}]},{"name":"Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum","path":"primitivnye literalnye tipy number, string, boolean, unique symbol, enum","sections":[{"name":"Примитивные типы — литеральные типы Number, String, Boolean, Unique Symbol, Enum","path":"primitivnye tipy — literalnye tipy number, string, boolean, unique symbol, enum"},{"name":"Литеральный тип Number (Numeric Literal Types)","path":"literalnyi tip number (numeric literal types)"},{"name":"Литеральный тип String (String Literal Types)","path":"literalnyi tip string (string literal types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"literalnyi tip boolean (boolean literal types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"literalnyi tip unique symbol (unique symbol) unikalnyi simvolnyi tip"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"literalnyi tip enum (enum literal types)"},{"name":"Итоги","path":"itogi"}]},{"name":"Object, Array, Tuple","path":"object, array, tuple","sections":[{"name":"Типы — Object, Array, Tuple","path":"tipy — object, array, tuple"},{"name":"Object (object) — ссылочный объектный тип","path":"object (object) — ssylochnyi obektnyi tip"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"array (type[]) ssylochnyi massivopodobnyi tip"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"tuple ([t0, t1, …, tn]) tip kortej"},{"name":"Итоги","path":"itogi"}]},{"name":"Function, Functional Types","path":"function, functional types","sections":[{"name":"Function, Functional Types","path":"function, functional types"},{"name":"Function Types - тип функция","path":"function types - tip funkciya"},{"name":"Functional Types - функциональный тип","path":"functional types - funkcionalnyi tip"},{"name":"this в сигнатуре функции","path":"this v signature funkcii"},{"name":"Итог","path":"itog"}]},{"name":"Interfaces","path":"interfaces","sections":[{"name":"Общая теория","path":"obshchaya teoriya"},{"name":"Интерфейс в TypeScript","path":"interfeis v typescript"},{"name":"Объявление (declaration)","path":"obyavlenie (declaration)"},{"name":"Конвенции именования интерфейсов","path":"konvencii imenovaniya interfeisov"},{"name":"Реализация интерфейса (implements)","path":"realizaciya interfeisa (implements)"},{"name":"Декларация свойств get и set (accessors)","path":"deklaraciya svoistv get i set (accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"ukazanie interfeisa v kachestve tipa (interface types)"},{"name":"Расширение интерфейсов (extends interface)","path":"rasshirenie interfeisov (extends interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"rasshirenie interfeisom klassa (extends class)"},{"name":"Описание класса (функции-конструктора)","path":"opisanie klassa (funkcii-konstruktora)"},{"name":"Описание функционального выражения","path":"opisanie funkcionalnogo vyrajeniya"},{"name":"Описание индексных членов в объектных типов","path":"opisanie indeksnyh chlenov v obektnyh tipov"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"inlain interfeisy (inline interface)"},{"name":"Слияние интерфейсов","path":"sliyanie interfeisov"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)","sections":[{"name":"Типы — Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"tipy — obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)","sections":[{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)"},{"name":"Модификатор доступа public (публичный)","path":"modifikator dostupa public (publichnyi)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"modifikator dostupa private (zakrytyi ili skrytyi)"},{"name":"Модификатор доступа protected (защищенный)","path":"modifikator dostupa protected (zashchishchennyi)"},{"name":"Модификаторы доступа и конструкторы класса","path":"modifikatory dostupa i konstruktory klassa"},{"name":"Быстрое объявление полей","path":"bystroe obyavlenie polei"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript","sections":[{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript"}]},{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)","sections":[{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)"},{"name":"Общие характеристики","path":"obshchie harakteristiki"},{"name":"Теория","path":"teoriya"}]},{"name":"Полиморфный тип this","path":"polimorfnyi tip this","sections":[{"name":"Полиморфный тип this","path":"polimorfnyi tip this"}]},{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)","sections":[{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)"}]},{"name":"Definite Assignment Assertion Modifier","path":"definite assignment assertion modifier","sections":[{"name":"Классы — Definite Assignment Assertion Modifier","path":"klassy — definite assignment assertion modifier"}]},{"name":"Классы — Тонкости","path":"klassy — tonkosti","sections":[{"name":"Классы — Тонкости","path":"klassy — tonkosti"},{"name":"Классы - Тонкости implements","path":"klassy - tonkosti implements"},{"name":"Частичное Слияние интерфейса с классом","path":"chastichnoe sliyanie interfeisa s klassom"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"pereopredelenie svoistv polyami i naoborot pri nasledovanii"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov","sections":[{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov"},{"name":"Итог","path":"itog"}]},{"name":"Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"optional, not-null, not-undefined, definite assignment assertion","sections":[{"name":"Операторы — Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"operatory — optional, not-null, not-undefined, definite assignment assertion"},{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"neobyazatelnye polya, parametry i metody (optional fields, parameters and methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"operator ! (non-null and non-undefined operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"operator ! (definite assignment assertion)"},{"name":"Итог","path":"itog"}]},{"name":"Обобщения (Generics)","path":"obobshcheniya (generics)","sections":[{"name":"Обобщения - общие понятия","path":"obobshcheniya - obshchie ponyatiya"},{"name":"Обобщения в TypeScript","path":"obobshcheniya v typescript"},{"name":"Параметры типа - extends (generic constraints)","path":"parametry tipa - extends (generic constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"parametra tipa - znachenie po umolchaniu = (generic parameter defaults)"},{"name":"Параметры типа - как тип данных","path":"parametry tipa - kak tip dannyh"}]},{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)","sections":[{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)"}]},{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa","sections":[{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa"}]},{"name":"Утверждение Типов (Type Assertion)","path":"utverjdenie tipov (type assertion)","sections":[{"name":"Утверждение Типов - общее","path":"utverjdenie tipov - obshchee"},{"name":"Утверждение Типа `<Type>` синтаксис","path":"utverjdenie tipa `<type>` sintaksis"},{"name":"Утверждение Типа с помощью оператора as","path":"utverjdenie tipa s pomoshchu operatora as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"privedenie (utverjdenie) k konstante (const assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"utverjdenie v signature (signature assertion)"},{"name":"Итоги","path":"itogi"}]},{"name":"Защитники типа","path":"zashchitniki tipa","sections":[{"name":"Защитники Типа - общее","path":"zashchitniki tipa - obshchee"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"sujenie diapazona mnojestva tipov na osnove tipa dannyh"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"sujenie diapazona mnojestva tipov na osnove priznakov prisushchih tipu tagged union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"sujenie diapazona mnojestva tipov na osnove dostupnyh chlenov obekta"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"sujenie diapazona mnojestva tipov na osnove funkcii, opredelennoi polzovatelem"}]},{"name":"Вывод типов","path":"vyvod tipov","sections":[{"name":"Вывод типов - общие сведения","path":"vyvod tipov - obshchie svedeniya"},{"name":"Вывод примитивных типов","path":"vyvod primitivnyh tipov"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"vyvod primitivnyh tipov dlya konstant (const) i polei tolko dlya chteniya (readonly)"},{"name":"Вывод объектных типов","path":"vyvod obektnyh tipov"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"vyvod tipa dlya polei klassa na osnove inicializacii ih v konstruktore"},{"name":"Вывод объединенных (Union) типов","path":"vyvod obedinennyh (union) tipov"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"vyvod peresecheniya (intersection) s diskriminantnymi polyami"},{"name":"Вывод типов кортеж (Tuple)","path":"vyvod tipov kortej (tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"sovmestimost obektnyh tipov (compatible object types)","sections":[{"name":"Важно","path":"vajno"},{"name":"Совместимость объектных типов в TypeScript","path":"sovmestimost obektnyh tipov v typescript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"sovmestimost funkcionalnyh tipov (compatible function types)","sections":[{"name":"важно","path":"vajno"},{"name":"Совместимость параметров","path":"sovmestimost parametrov"},{"name":"Совместимость возвращаемого значения","path":"sovmestimost vozvrashchaemogo znacheniya"}]},{"name":"Совместимость объединений (Union Types)","path":"sovmestimost obedinenii (union types)","sections":[{"name":"Совместимость","path":"sovmestimost"}]},{"name":"Типизация в TypeScript","path":"tipizaciya v typescript","sections":[{"name":"Общие сведения","path":"obshchie svedeniya"},{"name":"Статическая типизация (static typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)"},{"name":"Вариантность (variance)","path":"variantnost (variance)"},{"name":"Наилучший общий тип (Best common type)","path":"nailuchshii obshchii tip (best common type)"},{"name":"Контекстный тип (Contextual Type)","path":"kontekstnyi tip (contextual type)"},{"name":"Итог","path":"itog"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -","sections":[{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -"},{"name":"Запрос ключей keyof","path":"zapros kluchei keyof"},{"name":"Поиск типов (Lookup Types)","path":"poisk tipov (lookup types)"},{"name":"Сопоставление типов (Mapped Types)","path":"sopostavlenie tipov (mapped types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"prefiksy + i - v sopostavlennyh tipah"}]},{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)","sections":[{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"raspredelitelnye uslovnye tipy (distributive conditional types)"},{"name":"Вывод типов в условном типе","path":"vyvod tipov v uslovnom tipe"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"readonly, partial, required, pick, record","sections":[{"name":"Расширенные типы — Readonly, Partial, Required, Pick, Record","path":"rasshirennye tipy — readonly, partial, required, pick, record"},{"name":"Readonly","path":"readonly"},{"name":"Partial","path":"partial"},{"name":"Required","path":"required"},{"name":"Pick","path":"pick"},{"name":"Record","path":"record"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"exclude, extract, nonnullable, returntype, instancetype, omit","sections":[{"name":"Расширенные типы — Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"rasshirennye tipy — exclude, extract, nonnullable, returntype, instancetype, omit"},{"name":"Exclude","path":"exclude"},{"name":"Extract","path":"extract"},{"name":"NonNullable","path":"nonnullable"},{"name":"ReturnType","path":"returntype"},{"name":"InstanceType","path":"instancetype"},{"name":"Parameters","path":"parameters"},{"name":"ConstructorParameters","path":"constructorparameters"},{"name":"Тип Omit","path":"tip omit"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"massivopodobnye readonly tipy, readonlyarray, readonlymap, readonlyset","sections":[{"name":"Массивоподобные readonly типы","path":"massivopodobnye readonly tipy"},{"name":"ReadonlyArray","path":"readonlyarray"},{"name":"ReadonlyMap","path":"readonlymap"},{"name":"ReadonlySet","path":"readonlyset"}]},{"name":"Синтаксические конструкции и операторы","path":"sintaksicheskie konstrukcii i operatory","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"operatory prisvaivaniya korotkogo zamykaniya (&&=, ||=, &&=)"},{"name":"Операнды для delete должны быть необязательными","path":"operandy dlya delete doljny byt neobyazatelnymi"}]},{"name":"React - расширение .tsx","path":"react - rasshirenie .tsx","sections":[{"name":"React — расширение .tsx","path":"react — rasshirenie .tsx"}]},{"name":"Функциональные компоненты","path":"funkcionalnye komponenty","sections":[{"name":"Определение компонента как Function Declaration","path":"opredelenie komponenta kak function declaration"},{"name":"Определение компонента как Function Expression","path":"opredelenie komponenta kak function expression"}]},{"name":"Классовые компоненты","path":"klassovye komponenty","sections":[{"name":"React — производные от Component","path":"react — proizvodnye ot component"},{"name":"React - производные от PureComponent","path":"react - proizvodnye ot purecomponent"}]},{"name":"Универсальные компоненты","path":"universalnye komponenty","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"obobshchennye komponenty (generics component)"}]},{"name":"Типизированные хуки","path":"tipizirovannye huki","sections":[{"name":"Предопределенные хуки","path":"predopredelennye huki"},{"name":"Пользовательский хук","path":"polzovatelskii huk"}]},{"name":"Контекст (Context)","path":"kontekst (context)","sections":[{"name":"Определение контекста","path":"opredelenie konteksta"}]},{"name":"HOC (Higher-Order Components)","path":"hoc (higher-order components)","sections":[{"name":"Определение hoc","path":"opredelenie hoc"},{"name":"Определение hoc на основе функционального компонента","path":"opredelenie hoc na osnove funkcionalnogo komponenta"},{"name":"Определение hoc на основе классового компонента","path":"opredelenie hoc na osnove klassovogo komponenta"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"prostranstva imen (namespace) i moduli (module)","sections":[{"name":"Namespace и module — предназначение","path":"namespace i module — prednaznachenie"},{"name":"Namespace - определение","path":"namespace - opredelenie"},{"name":"Модули (export, import) — определение","path":"moduli (export, import) — opredelenie"},{"name":"Конфигурирование проекта","path":"konfigurirovanie proekta"}]},{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya","sections":[{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"sborka proekta s pomoshchu tsc (typescript compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"sborka s ispolzovaniem ssylok na proekty","sections":[{"name":"Ссылки на проекты","path":"ssylki na proekty"}]},{"name":"Декларации","path":"deklaracii","sections":[{"name":"Что такое декларация (Declaration)","path":"chto takoe deklaraciya (declaration)"},{"name":"Установка деклараций с помощью @types","path":"ustanovka deklaracii s pomoshchu @types"},{"name":"Подготовка к созданию декларации","path":"podgotovka k sozdaniu deklaracii"},{"name":"Разновидности деклараций","path":"raznovidnosti deklaracii"},{"name":"Декларации и область видимости","path":"deklaracii i oblast vidimosti"},{"name":"Декларации для библиотек с одной точкой входа","path":"deklaracii dlya bibliotek s odnoi tochkoi vhoda"},{"name":"Декларации для библиотек с множеством точек входа","path":"deklaracii dlya bibliotek s mnojestvom tochek vhoda"},{"name":"Создание деклараций вручную","path":"sozdanie deklaracii vruchnuu"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"direktiva s troinym sleshem (triple-slash directives)"},{"name":"Импортирование декларации (import)","path":"importirovanie deklaracii (import)"}]},{"name":"Публикация","path":"publikaciya","sections":[{"name":"Публикация","path":"publikaciya"}]},{"name":"Опции компилятора","path":"opcii kompilyatora","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressexcesspropertyerrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressimplicitanyindexerrors"},{"name":"noImplicitAny","path":"noimplicitany"},{"name":"checkJs","path":"checkjs"},{"name":"JSX","path":"jsx"},{"name":"jsxFactory","path":"jsxfactory"},{"name":"target (t)","path":"target (t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysstrict"},{"name":"strictNullChecks","path":"strictnullchecks"},{"name":"stripInternal","path":"stripinternal"},{"name":"noImplicitThis","path":"noimplicitthis"},{"name":"noImplicitUseStrict","path":"noimplicitusestrict"},{"name":"baseUrl","path":"baseurl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootdir"},{"name":"rootDirs","path":"rootdirs"},{"name":"traceResolution","path":"traceresolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"nolib"},{"name":"noResolve","path":"noresolve"},{"name":"noStrictGenericChecks","path":"nostrictgenericchecks"},{"name":"preserveConstEnums","path":"preserveconstenums"},{"name":"removeComments","path":"removecomments"},{"name":"noUnusedLocals","path":"nounusedlocals"},{"name":"noUnusedParameters","path":"nounusedparameters"},{"name":"skipLibCheck","path":"skiplibcheck"},{"name":"declarationDir","path":"declarationdir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeroots"},{"name":"allowUnusedLabels","path":"allowunusedlabels"},{"name":"noImplicitReturns","path":"noimplicitreturns"},{"name":"noFallthroughCasesInSwitch","path":"nofallthroughcasesinswitch"},{"name":"outFile","path":"outfile"},{"name":"allowSyntheticDefaultImports","path":"allowsyntheticdefaultimports"},{"name":"allowUnreachableCode","path":"allowunreachablecode"},{"name":"allowJs","path":"allowjs"},{"name":"reactNamespace","path":"reactnamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleresolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noemithelpers"},{"name":"newLine","path":"newline"},{"name":"inlineSourceMap","path":"inlinesourcemap"},{"name":"inlineSources","path":"inlinesources"},{"name":"noEmitOnError","path":"noemitonerror"},{"name":"noEmit","path":"noemit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downleveliteration"},{"name":"emitBOM","path":"emitbom"},{"name":"emitDecoratorMetadata","path":"emitdecoratormetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceconsistentcasinginfilenames"},{"name":"help (h)","path":"help (h)"},{"name":"importHelpers","path":"importhelpers"},{"name":"isolatedModules","path":"isolatedmodules"},{"name":"listEmittedFiles","path":"listemittedfiles"},{"name":"listFiles","path":"listfiles"},{"name":"sourceRoot","path":"sourceroot"},{"name":"mapRoot","path":"maproot"},{"name":"maxNodeModuleJsDepth","path":"maxnodemodulejsdepth"},{"name":"project (p)","path":"project (p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version (v)"},{"name":"watch (w)","path":"watch (w)"},{"name":"preserveSymlinks","path":"preservesymlinks"},{"name":"strictFunctionTypes","path":"strictfunctiontypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctpropertyinitialization"},{"name":"esModuleInterop","path":"esmoduleinterop"},{"name":"emitDeclarationsOnly","path":"emitdeclarationsonly"},{"name":"resolveJsonModule","path":"resolvejsonmodule"},{"name":"declarationMap","path":"declarationmap"},{"name":"strictBindCallApply","path":"strictbindcallapply"},{"name":"showConfig","path":"showconfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsbuildinfofile"},{"name":"allowUmdGlobalAccess","path":"allowumdglobalaccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disablesourceofprojectreferenceredirect"},{"name":"useDefineForClassFields","path":"usedefineforclassfields"},{"name":"importsNotUsedAsValues","path":"importsnotusedasvalues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumechangesonlyaffectdirectdependencies"},{"name":"watchFile","path":"watchfile"},{"name":"watchDirectory","path":"watchdirectory"},{"name":"fallbackPolling","path":"fallbackpolling"},{"name":"synchronousWatchDirectory","path":"synchronouswatchdirectory"}]}]}},"staticQueryHashes":["408059355","63159454"]}