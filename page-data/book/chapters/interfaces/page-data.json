{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/interfaces","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Подробное руководство по языку TypeScript, которое шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Interfaces","section":"Типы","path":"interfaces","subtitles":[{"subtitle":"Общая теория","path":"interfaces#obshchaya teoriya"},{"subtitle":"Интерфейс в TypeScript","path":"interfaces#interfeis v typescript"},{"subtitle":"Объявление (declaration)","path":"interfaces#obyavlenie (declaration)"},{"subtitle":"Конвенции именования интерфейсов","path":"interfaces#konvencii imenovaniya interfeisov"},{"subtitle":"Реализация интерфейса (implements)","path":"interfaces#realizaciya interfeisa (implements)"},{"subtitle":"Декларация свойств get и set (accessors)","path":"interfaces#deklaraciya svoistv get i set (accessors)"},{"subtitle":"Указание интерфейса в качестве типа (interface types)","path":"interfaces#ukazanie interfeisa v kachestve tipa (interface types)"},{"subtitle":"Расширение интерфейсов (extends interface)","path":"interfaces#rasshirenie interfeisov (extends interface)"},{"subtitle":"Расширение интерфейсом класса (extends class)","path":"interfaces#rasshirenie interfeisom klassa (extends class)"},{"subtitle":"Описание класса (функции-конструктора)","path":"interfaces#opisanie klassa (funkcii-konstruktora)"},{"subtitle":"Описание функционального выражения","path":"interfaces#opisanie funkcionalnogo vyrajeniya"},{"subtitle":"Описание индексных членов в объектных типов","path":"interfaces#opisanie indeksnyh chlenov v obektnyh tipov"},{"subtitle":"Инлайн интерфейсы (Inline Interface)","path":"interfaces#inlain interfeisy (inline interface)"},{"subtitle":"Слияние интерфейсов","path":"interfaces#sliyanie interfeisov"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Interfaces</span></h1><p>Несмотря на то, что тема относящаяся к интерфесам очень проста, именно она вызывает наибольшее количество вопросов у начинающих разработчиков. Поэтому такие вопросы как для чего нужны интерфейсы, когда их применять, а когда нет, будет подробно рассмотренны в этой главе.</p></section>\n<section class=\"content__section\" id=\"obshchaya_teoriya\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"obshchaya teoriya\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Общая теория</span></h2><p>По факту интерфейс затрагивает сразу несколько аспектов создания программ относящихся к проектированию, реализации, конечной сборке. Поэтому чтобы понять предназначение интерфейса необходимо рассмотреть каждый аспект по отдельности.</p><p>Первый аспект (реализация) предлагает рассматривать создаваемые экземпляры как социальные объекты чья публичная часть инфраструктуры была оговорена в контракте, к коему относится интерфейс. Другими словами интерфейс это контракт реализация которого гарантирует наличие оговоренных в нем членов потребителю экземпляра. Поскольку интерфейс описывает исключительно типы членов объекта (поля, свойства, сигнатуры методов) они не могут гарантировать что сопряженная с ними логика будет соответствовать каким-либо критериям. Поэтому случаю была принята методология называемая <em>контрактное программирование</em>. Несмотря на то что данная методология вызывает непонимание у большинства начинающих разработчиков, в действительности она очень проста. За этим таинственным термином скрываются рекомендации придерживатся устной или писменной спецификации при реализации логики сопряженной с оговоренными в интерфейсе членами.</p><p>Второй аспект (проектирование) предлагает проектировать объекты менее независимыми за счет отказа от конкретных типов (классов) в пользу интерфейсов. Ведь пока тип переменной или параметра представляется классовым типом, невозможно будет присвоить значение соответствующее, но не совместимое с ним. Под соответствующим имеется ввиду соответствующим по всем признакам, но не состоящим в отношениях наследовния. И хотя в <em>TypeScript</em> из-за реализации <em>номинативной типизации</em> подобной проблемы не существует, по возможности рекомендуется придерживатся классических взглядов.</p><p>Третий аспект (сборка) вытекает из второго и предполагает уменьшение размера компилируемого пакета (<em>bandle</em>) за счет отказа от конкретных типов (классов). Фактически если какой-либо объект требуется пакету лишь для выполнения операций над ним, последнему вовсе не нужно содержать определение первого. Другими словами скомпелированный пакет не должен включать определение класса со всей его логикой только потому, что он указан в качестве типа. Для этого как нельзя лучше подходят типы представленные интерфейсами. Хотя нельзя не упомянуть о том, что данная проблема не имеет никакого практического отношения к разработчикам на языке <em>TypeScript</em> поскольку его (или точнее сказать <em>JavaScript</em>) модульная система лишена подобного недостатка.</p><p>Вот эти несколько строк описывающие оговоренные в самом начале аспекты заключают в себе ответы на все возможные вопросы которые только могут возникнуть относительно темы сопряженной с интерфейсами. Если ещё более доступно, то интерфейсы нужны для снижения зависимости и наложения обязательств на реализующие их классы. Кроме того интерфейсы стоит применять всегда и везде где только можно. Это не только повысит семантическую привлекательность кода, но и сделает его более поддерживаемым.</p><p>Не лишним будет добавить что интерфейсы являются фундаментальной составляющей идеологии как типизированных языков, так и объектно-ориентированного программирования.</p><p>Такая известная группа программистов, как <em>“Банда четырех”</em> (<em>Gang of Four</em>, сокращённо <em>GoF</em>), в своей книге, положившей начало популяризации шаблонов проектирования, описывали интерфейс как ключевую концепцию <em>объектно-ориентированного программирования</em> (<em>ооп</em>). Понятие интерфейса является настолько важным, что в книге был сформулирован принцип объектно-ориентированного проектирования, который звучит так: <em>Программируйте в соответствии с интерфейсом, а не с реализацией.</em></p><p>Другими словами, авторы советуют создавать систему, которой вообще ничего не будет известно о реализации. Проще говоря, создаваемая система должна быть построена на типах, определяемых интерфейсами, а не на типах, определяемых классами.</p><p>С теорией закончено. Осталось подробно рассмотреть реализацию интерфейсов в <em>TypeScript</em>.</p></section>\n<section class=\"content__section\" id=\"interfeis_v_typescript\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"interfeis v typescript\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Интерфейс в TypeScript</span></h2><p><em>TypeScript</em> предлагает новый тип данных, определяемый с помощью синтаксической конструкции называемой <em>интерфейс</em> (<code>interface</code>). </p><p><code>Interface</code> — это синтаксическая конструкция предназначенная для описания открытой (<code>public</code>) части объекта без реализации. Хотя не будет лишним упомянуть, что существуют языки позволяющие реализовывать в интерфейсах поведение рассматриваемое как по умолчанию.</p><p>Класс, реализующий интерфейс, обязан реализовать все описанные в нём члены. Поэтому интерфейс является гарантией наличия описанных в нем характеристик у реализующего его объекта. Все члены, описанные в интерфейсе, неявно имеют модификатор доступа <code>public</code>. Интерфейс предназначен для описания <em>api</em> или другими словами состояния и поведенея предназначенного для взвимодействия внешнего мира с объектом.</p></section>\n<section class=\"content__section\" id=\"obyavlenie_(declaration)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"obyavlenie (declaration)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Объявление (declaration)</span></h2><p>В <em>TypeScript</em> интерфейс объявляется с помощью ключевого слова <code>interface</code> после которого указывается идентификатор за которым следует тело заключенное в фигурные скобки содержащие описание.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface Identifier {\n    // тело интерфейса \n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Объявление интерфейса возможно как в контексте модуля, так и в контексте функции или метода.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface Identifier {} // контекст модуля\n\nclass T {\n    public method(): void {\n        interface Identifier {} // контекст метода\n    }\n}\n\nfunction func(): void {\n   interface Identifier {} // контекст функции\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"konvencii_imenovaniya_interfeisov\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"konvencii imenovaniya interfeisov\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Конвенции именования интерфейсов</span></h2><p>Прежде чем продолжить, нужно обратить внимание на такой аспект, как конвенции именования интерфейсов. Существует два вида именования. </p><p>Первый вид конвенций родом из языка <em>Java</em> — они предлагают именовать интерфейсы точно так же, как и классы. Допускаются имена прилагательные.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface Identifier {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Второй вид предлагает использовать конвенции языка <em>C#</em>, по которым интерфейсы именуются так же как классы, но с префиксом <code>I</code>, что является сокращением от <em>Interface</em>. Такой вид записи получил название <em>“венгерская нотация”</em> в честь программиста венгерского происхождения, работавшего в компании <em>MicroSoft</em>. Допускаются имена прилагательные.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IIdentifier {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Чтобы сразу расставить все точки над i, стоит заметить, что в дальнейшем идентификаторы интерфейсов будут указываться по конвенциям <em>C#</em>.</p></section>\n<section class=\"content__section\" id=\"realizaciya_interfeisa_(implements)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"realizaciya interfeisa (implements)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Реализация интерфейса (implements)</span></h2><p>Как уже было сказано в самом начале, все члены интерфейса являются открытыми (<code>public</code>) и их объявление не может содержать модификатор <code>static</code>. Кроме того, в <em>ypeScript</em> интерфейсы не могут содержать реализацию.</p><p>Класс реализующий интерфейс обязан реализовывать его в полной мере. Любой класс, который хочет реализовать интерфейс должен указать это с помощью ключевого слова <code>implements</code>, после которого следует идентификатор реализуемого интерфейса. Указание реализации классом интерфейса располагается между идентификатором класса и его телом. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    nickname: string;\n    \n    execute(command: string): void;\n}\n\nclass Bird implements IAnimal {\n    nickname: string;\n    \n    execute(command: string): void {}\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Один класс может реализовывать сколько угодно интерфейсов. В этом случае реализуемые интерфейсы должны быть перечислены через запятую.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {}\ninterface IOviparous {} // указывает на возможность откладывать яйца\n\nclass Bird implements IAnimal, IOviparous {} </code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В случае, когда класс расширяет другой класс, декларация реализации (<code>implements</code>) следует после декларации расширения (<code>extends</code>).</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {}\ninterface IOviparous {} \n\nclass Bird implements IAnimal, IOviparous {} \n\ninterface IFlyable {}\n\nclass Eagle extends Bird implements IFlyable {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"deklaraciya_svoistv_get_i_set_(accessors)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"deklaraciya svoistv get i set (accessors)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Декларация свойств get и set (accessors)</span></h2><p>Несмотря на то, что в интерфейсе можно декларировать поля и методы, в нем нельзя декларировать свойства <code>get</code> и <code>set</code> (<em>аксессоры</em>). Но, несмотря на это, задекларированное в интерфейсе поле может быть совместимо не только с полем, но и аксессорами. При этом нет разницы, будет в объекте объявлен <em>getter</em>, <em>setter</em> или оба одновременно.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    id: string;\n}\n\n// только get\nclass Bird implements IAnimal {\n    get id(): string {\n        return &#39;bird&#39;;\n    }\n}\n\n// только set\nclass Fish implements IAnimal {\n    set id(value: string) {}\n}\n\n// и get и set\nclass Insect implements IAnimal {\n    get id(): string {\n     return &#39;insect&#39;;\n    }\n\n    set id(value: string) {}\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"ukazanie_interfeisa_v_kachestve_tipa_(interface_types)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"ukazanie interfeisa v kachestve tipa (interface types)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Указание интерфейса в качестве типа (interface types)</span></h2><p>Класс реализующий интерфейс принадлежит к типу этого интерфейса. Класс унаследованный от класса реализующего интерфейс, также наследует принадлежность к реализуемым им интерфейсам. В подобных сценариях говорят что класс наследует интерфейс.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {}\n\nclass Bird implements IAnimal {}\n\nclass Raven extends Bird {}\n\nlet bird: IAnimal = new Bird();\nlet raven: IAnimal = new Raven();</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Класс, реализующий множество интерфейсов, принадлежит к типу каждого из них. Когда экземпляр класса реализующего интерфейс присваивают ссылке с типом интерфейса, то говорят что экземпляр был <em>ограничен</em> типом интерфейса. То есть, функционал экземпляра класса урезается до описанного в интерфейсе (подробнее об этом речь пойдет в главе <a href=\"/book/chapters/sovmestimost%20obektnyh%20tipov%20(compatible%20object%20types)\">“Типизация - Совместимость объектов”</a> и <a href=\"/book/chapters/sovmestimost%20funkcionalnyh%20tipov%20(compatible%20function%20types)\">“Типизация - Совместимость функций”</a>). </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    name: string;\n}\n\ninterface IFlyable {\n    flightHeight: number;\n}\n\ninterface IIdentifiable {\n    id: string;\n}\n\nclass Animal implements IAnimal {\n    constructor(readonly name: string) {}\n}\n\nclass Bird extends Animal implements IFlyable {\n    public flightHeight: number = 500;\n}\n\nvar animal: IAnimal = new Bird(&#39;bird&#39;); // экземпляр Bird ограничен до типа IAnimal\nvar fly: IFlyable = new Bird(&#39;bird&#39;); // экземпляр Bird ограничен до типа IFlyable</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Несмотря на то, что интерфейс является синтаксической конструкцией и может указываться в качестве типа, после компиляции от него не остается и следа. Это в свою очередь означает, что интерфейс, как тип данных, может использоваться только на этапе компиляции. Другими словами, компилятор сможет предупредить об ошибках несоответствия объекта описанному интерфейсу, но проверить на принадлежность к типу интерфейса с помощью операторов <code>typeof</code> или <code>instanceof</code> не получится поскольку они выполняются во время выполнения программы. Но в <em>TypeScript</em> существует механизм (который будет рассмотрен далее в главе <a href=\"/book/chapters/zashchitniki%20tipa\">“Типизация - Защитники типа”</a>), позволяющий в некоторой мере решить эту проблему.</p></section>\n<section class=\"content__section\" id=\"rasshirenie_interfeisov_(extends_interface)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"rasshirenie interfeisov (extends interface)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Расширение интерфейсов (extends interface)</span></h2><p>Если множество логически связанных интерфейсов требуется объединить в один тип, то нужно воспользоваться механизмом расширения интерфейсов. Наследование интерфейсов осуществляется с помощью ключевого слова <code>extends</code>, после которого через запятую идет один или несколько идентификаторов расширяемых интерфейсов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IIdentifiable {}\ninterface ILiving {}\n\n// интерфейсы IIdentifiable и ILiving вместе образуют логически связанную композицию, \n// которую можно выделить в тип интерфейс IAnimal\ninterface IAnimal extends IIdentifiable, ILiving {}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Для тех кто только знакомится с таким понятием как интерфейсы, будет не лишним узнать о <em>“Принципе разделения интерфейсов”</em> (<em>Interface Segregation Principle</em> или сокращенно <em>ISP</em>), который гласит, что более крупные интерфейсы нужно <em>“дробить”</em> на более мелкие интерфейсы. Но нужно понимать, что условия дробления диктуются конкретным приложением. Если во всех случаях руководствоваться только принципами, то можно раздуть небольшое приложение до масштабов вселенной.</p><p>Для примера представьте приложение, которое только выводит в консоль информацию о животных. Так как над объектом <code>Animal</code> будет выполняться только одна операция, то можно не бояться разгневать богов объектно-ориентированного проектирования и включить все нужные характеристики прямо в интерфейс <code>IAnimal</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    id: string;\n    age: number;\n}\n\nclass Animal implements IAnimal {\n    public age: number = 0;\n    \n    constructor(readonly id: string) {}\n}\n\nclass AnimalUtil {\n    public static print(animal: IAnimal): void {\n        console.log(animal);\n    }\n}\n\nclass Bird extends Animal {}\n\nclass Raven extends Bird {\n    constructor() {\n        super(&#39;raven&#39;);\n    }\n}\n\nlet raven: Raven = new Raven();\n\nAnimalUtil.print(raven);</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В такой программе, кроме достоинства архитектора, ничего пострадать не может, так как она выполняет только одну операцию вывода информации о животном.</p><p>Но если переписать программу, чтобы она выполняла несколько не связанных логически операций над одним типом, в данном случае <code>IAnimal</code>, то ситуация изменится на противоположную.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {/*...*/}\n\nclass Animal implements IAnimal {/*...*/}\n\nclass AnimalUtil {\n    public static printId(animal: IAnimal): void {\n        console.log(animal.id); // вывод  id\n    }\n\n    public static printAge(animal: IAnimal): void {\n        console.log(animal.age); // вывод age\n    }\n}\n\nclass Bird extends Animal {}\nclass Raven extends Bird {/*...*/}\n\nlet raven: Raven = new Raven();\n\nAnimalUtil.printId(raven);\nAnimalUtil.printAge(raven);</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В этом случае программа нарушает принцип <em>ISP</em>, так как статические методы <code>printId</code> и <code>printAge</code> получили доступ к данным, которые им не требуются для успешного выполнения. Это может привести к намеренной или по неосторожности порче данных.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class AnimalUtil {\n    public static printId(animal: IAnimal): void {\n        // для успешного выполнения этого метода \n        // не требуется доступ к данным о animal.age\n        console.log(animal.id);\n    }\n\n public static printAge(animal: IAnimal): void {\n        // для успешного выполнения этого метода \n        // не требуется доступ к данным о animal.id\n        console.log(animal.age);\n    }\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Поэтому в подобных ситуациях настоятельно рекомендуется <em>“дробить”</em> типы интерфейсов на меньшие составляющие и затем ограничивать ими доступ к данным.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IIdentifiable {}\ninterface ILiving {}\n\ninterface IAnimal extends IIdentifiable, ILiving {/*...*/}\n\nclass Animal implements IAnimal {/*...*/}\n\nclass AnimalUtil {\n    public static printId(animal: IIdentifiable): void {\n        // параметр animal ограничен типом IIdentifiable\n        console.log(animal.id);\n    }\n\n    public static printAge(animal: ILiving): void {\n        // параметр animal ограничен типом ILiving\n        console.log(animal.age);\n    }\n}\n\nclass Bird extends Animal {}\nclass Raven extends Bird {/*...*/}\n\nlet raven: Raven = new Raven();\n\nAnimalUtil.printId(raven);\nAnimalUtil.printAge(raven);</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"rasshirenie_interfeisom_klassa_(extends_class)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"rasshirenie interfeisom klassa (extends class)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Расширение интерфейсом класса (extends class)</span></h2><p>В случаях, когда нужно создать интерфейс для уже имеющегося класса, больше не нужно тратить силы на перечисление членов класса в интерфейсе. В <em>TypeScript</em> интерфейсу достаточно расширить тип класса.</p><p>Когда интерфейс расширяет класс, он наследует описание членов, но не их реализацию.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal {\n    nickname: string;\n    age: number;\n}\n\ninterface IAnimal extends Animal {}\n\nclass Bird implements IAnimal {\n    nickname:string;\n    age: number;\n}\n\nlet bird: IAnimal = new Bird();</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Но с расширением класса интерфейсом существует один нюанс.</p><p>Интерфейс полученный путем расширения типа класса может быть реализован только самим этим классом или его потомками, поскольку помимо публичных (<code>public</code>) также наследует закрытые (<code>private</code>) и защищенные (<code>protected</code>) члены.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Animal {\n    private uid: string;\n    protected maxAge: number;\n    public name: string;\n}\n\ninterface IAnimal extends Animal {}\n\nclass Bird extends Animal implements IAnimal { // Ok\n    // private uid: string = &#39;&#39;; // Error, private\n    protected maxAge: number = 100; // Ok, protected\n    public name: string = &#39;bird&#39;; // Ok,  public\n}\n\nclass Fish implements IAnimal { // Error\n    public name: string = &#39;fish&#39;;\n}\n\nlet bird: IAnimal = new Bird(); // Ok\nlet fish: IAnimal = new Fish(); // Error</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"opisanie_klassa_(funkcii-konstruktora)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"opisanie klassa (funkcii-konstruktora)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Описание класса (функции-конструктора)</span></h2><p>Известный факт, что в <em>JavaScript</em>, а следовательно и в <em>TypeScript</em>, конструкция <code>class</code> - это лишь <em>“синтаксический сахар”</em> над старой доброй функцией-конструктором. Эта особенность позволяет описывать интерфейсы не только для экземпляров класса, но и для самих классов (функций-конструкторов). Проще говоря, с помощью интерфейса можно описать как конструктор, так и статические члены класса, с одной оговоркой — этот интерфейс можно использовать только в качестве типа. То есть класс не может указывать реализацию такого интерфейса с помощью ключевого слова <code>implements</code> сопряженную с экземпляром, а не самим классом.</p><p>Описывать интерфейс для функции конструктора может потребоваться тогда, когда в качестве значения выступает сам класс.</p><p>Конструктор указывается с помощью ключевого слова <code>new</code>, затем открываются фигурные скобки в которых, при наличии, указываются параметры. В конце указывается тип возвращаемого значения.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">new(p1: type, p2: type): type;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Статические члены описываются также, как и обычные.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    nickname: string;\n}\n\nclass Animal implements IAnimal {\n    nickname: string;\n\n    constructor(nickname: string) { \n        this.nickname = nickname;\n    }\n}\n\nclass Bird extends Animal {\n    static DEFAULT_NAME: string = &#39;bird&#39;;\n\n    static create(): IAnimal {\n        return new Bird( Bird.DEFAULT_NAME);\n    }\n}\n\nclass Fish extends Animal {\n    static DEFAULT_NAME: string = &#39;bird&#39;;\n    \n    static create(): IAnimal {\n        return new Bird( Bird.DEFAULT_NAME);\n    }\n}\n\nconst bird: Bird = new Bird(&#39;bird&#39;);\nconst fish: Fish = new Fish(&#39;fish&#39;);\n\nlet a: IAnimal[] = [bird, fish]; // Ok, массив экземпляров классов реализующих интерфейс IAnimal\nlet b: IAnimal[] = [Bird, Fish]; // Error, массив классов\n\ninterface IAnimalConstructor { // декларация интерфейса для класса\n    create(): IAnimal; // static method\n    new (nickname: string): IAnimal; // конструктор\n}\n\nlet c: IAnimalConstructor[] = [Bird, Fish]; // Ok, массив классов\nlet d: IAnimal[] = c.map(item =&gt; item.create()); // Ok, массив экземпляров классов реализующих интерфейс IAnimal</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"opisanie_funkcionalnogo_vyrajeniya\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"opisanie funkcionalnogo vyrajeniya\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Описание функционального выражения</span></h2><p>Помимо экземпляров и самих классов, интерфейсы могут описывать функциональные выражения. Это очень удобно, когда функциональный тип имеет очень большую сигнатуру, которая делает код менее читабельным. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue?: T): T;\nvar callback: (previusValue: number, currentValue: number, currentIndex: number, array: number[]) =&gt; number;</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>В большинство подобных случаев, можно прибегнуть к помощи вывода типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue?: T): T;\n\nvar callback: (previusValue: number, currentValue: number, currentIndex: number, array: number[]) =&gt; number;\nvar callback = (previusValue: number, currentValue: number, currentIndex: number, array: number[]) =&gt; previusValue + currentValue;\n\nlet numberAll: number[] = [5, 5, 10, 30];\n\nlet sum: number = numberAll.reduce(callback); // 50</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Но в случае, если функциональное выражение является параметром функции, как например метод массива <code>reduce</code>, то решением может служить только явная декларация типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">class Collection&lt;T&gt; {\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue?: T): T {\n        return null;\n    }\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Поэтому при необходимости указать тип явно, помимо рассмотренного в главе <a href=\"/book/chapters/type%20queries%20(zaprosy%20tipa),%20alias%20(psevdonimy%20tipa)\">\"Типы - Type Queries (запросы типа), Alias (псевдонимы типа)\"</a> механизма создания псевдонимов типа (<code>type</code>), можно описать функциональное выражение с помощью интерфейса.</p><p>Для этого необходимо в теле интерфейса описать сигнатуру функции без указания идентификатора.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface ISumAll {\n    (...valueAll: number[]): number;\n}\n\nconst sumAll: ISumAll = (...valueAll: number[]) =&gt;\n    valueAll.reduce((result, value) =&gt; result += value, 0);\n\n\nlet numberAll: number[] = [5, 5, 10, 30];\n\nlet sum: number = sumAll(...numberAll);</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"opisanie_indeksnyh_chlenov_v_obektnyh_tipov\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"opisanie indeksnyh chlenov v obektnyh tipov\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Описание индексных членов в объектных типов</span></h2><p>Индексные члены подробно будут рассматриваться в главе <a href=\"/book/chapters/obektnye%20tipy%20s%20indeksnymi%20chlenami%20(obektnyi%20tip%20s%20dinamicheskimi%20kluchami)\">“Типы - Объектные типы с индексными членами (объектный тип с динамическими ключами)”</a>, но не будет лишним и здесь коснутся этого механизма.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IIndentifier  {\n    [BindingIdentifier: string]: Type;\n    [BindingIdentifier: number]: Type;\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"inlain_interfeisy_(inline_interface)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"inlain interfeisy (inline interface)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Инлайн интерфейсы (Inline Interface)</span></h2><p>Помимо описания объекта, в конструкции объявляемой с помощью ключевого слова <code>interface</code>, тип объекта можно описать прямо в месте указания типа. Такой способ объявления типа неформально обозначается как <em>инлайн интерфейс</em> (<em>)inline interface</em>). Всё ранее описанное для типов интерфейсов объявленных с помощью ключевого слова <code>interface</code>, в полной мере верно и для их инлайн аналогов.</p><p>Различие между обычным интерфейсом и инлайн интерфейсом в том, что второй обладает только телом и объявляется прямо в аннотации типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">let identifier: { p1: type, p2: type };</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Интерфейс, объявленный с помощью ключевого слова <code>interface</code>, считается идентичным инлайн интерфейсу, если их описание совпадает. Но стоит обратить внимание, что это возможно благодаря структурной типизации, которая рассматривается в главе <a href=\"/book/chapters/sovmestimost%20tipov%20na%20osnove%20vida%20tipizacii\">“Экскурс в типизацию - Совместимость типов на основе вида типизации”</a>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    nickname: string;\n}\n\nclass Bird implements IAnimal {\n    nickname: string;\n}\nclass Fish implements IAnimal {\n    nickname: string;\n}\n\nlet bird: IAnimal = new Bird(); // Ok\nlet fish: { nickname: string } = new Fish(); // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Как было сказано ранее, инлайн интерфейс можно объявлять в тех местах, в которых допускается указание типа. Тем не менее реализовывать (<code>implements</code>) и расширять (<code>extends</code>) инлайн интерфейс нельзя. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IT1{}\ninterface IT2{}\n\ninterface IT3 extends { f1: IT1, f2: IT2 } { // Error\n\n}\n\nclass T4 implements { f1: T1, f2: T2 } { // Error\n\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Хотя последнее утверждение и не совсем верно. В дальнейшем будет рассказано о такой замечательной конструкции, как обобщения (глава <a href=\"/book/chapters/obobshcheniya%20(generics)\">“Типы - Обобщения (Generics)”</a>), в которых, как раз таки возможно расширять (<code>extends</code>) инлайн интерфейсы.</p></section>\n<section class=\"content__section\" id=\"sliyanie_interfeisov\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"sliyanie interfeisov\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Слияние интерфейсов</span></h2><p>В случае, если в одной области видимости объявлено несколько одноимённых интерфейсов, то они будут объединены в один.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">// так видят разработчики\ninterface IAnimal {\n    name: string;\n}\n\ninterface IAnimal {\n    age: number;\n}\n\n//так видит компилятор\n/**\ninterface IAnimal {\n    name: string;\n    age: number;\n}\n*/\n\n// разработчики получают то, что видит компилятор\nlet animal: IAnimal;\nanimal.name = &#39;animal&#39;; // Ok\nanimal.age = 0; // Ok</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>При попытке переопределить тип поля, возникнет ошибка.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IAnimal {\n    name: string;\n    age: number;\n}\n\ninterface IAnimal {\n    name: string; // Ok\n    age: string; // Error\n}</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Если в нескольких одноимённых интерфейсах будут описаны одноимённые методы с разными сигнатурами, то они будут расценены, как описание перегрузки. К тому же, интерфейсы, которые описывают множество одноимённых методов, сохраняют свой внутренний порядок.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IBird {}\ninterface IFish {}\ninterface IInsect {}\ninterface IReptile {}\n\n// до компиляции\ninterface IAnimalFactory { \n    getAnimalByID(id: number): IBird;\n}\n\ninterface IAnimalFactory {\n    getAnimalByID(id: string): IFish;\n}\n\ninterface IAnimalFactory {\n    getAnimalByID(id: boolean): IInsect;\n    getAnimalByID(id: object): IReptile;\n}\n\n/** при компиляции\ninterface IAnimalFactory { \n    getAnimalByID(id: string): IInsect;\n    getAnimalByID(id: string): IReptile;\n    getAnimalByID(id: string): IFish;\n    getAnimalByID(id: string): IBird;\n}\n*/\nlet animal: IAnimalFactory;\nlet v1 = animal.getAnimalByID(0); // Ok -&gt; v1: IBird\nlet v2 = animal.getAnimalByID(&#39;5&#39;); // Ok -&gt; v2: IFish\nlet v3 = animal.getAnimalByID(true); // Ok -&gt; v3: IInsect\nlet v4 = animal.getAnimalByID({}); // Ok -&gt; v4: IReptile</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p>Исключением из этого правила являются сигнатуры, которые имеют в своем описании литеральные строковые типы данных (<code>literal String Types</code>). Дело в том, что сигнатуры содержащие в своем описании литеральные строковые типы, всегда размещаются перед сигнатурами, у которых нет в описании литеральных строковых типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts[object object]\"><pre class=\"language-ts[object object]\"><code class=\"language-ts[object object]\">interface IBird {}\ninterface IFish {}\ninterface IInsect {}\ninterface IReptile {}\n\n// до компиляции\ninterface IAnimalFactory { \n    getAnimalByID(id: string): IBird;\n}\n\ninterface IAnimalFactory {\n    getAnimalByID(id: &#39;fish&#39;): IFish;\n}\n\ninterface IAnimalFactory {\n    getAnimalByID(id: &#39;insect&#39;): IInsect;\n    getAnimalByID(id: number): IReptile;\n}\n\n/** при компиляции\ninterface IAnimalFactory {\n    getAnimalByID(id: &#39;fish&#39;): IFish;\n    getAnimalByID(id: &#39;insect&#39;): IInsect;\n    getAnimalByID(id: number): IReptile;\n    getAnimalByID(id: string): IBird;\n}\n*/</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>","commitInfoAll":[{"committedDate":"2020-09-08T11:53:53Z","message":"book(технические изменения (link, md, т.п.)): change code wrapper\n\nchange code wrapper from ~ to ` and from typescript to ts","messageHeadline":"book(технические изменения (link, md, т.п.)): change code wrapper","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars3.githubusercontent.com/u/31518738?v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/021\\.\\(Типы\\) Interfaces/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"chto takoe i dlya chego nujen typescript","sections":[{"name":"Что такое TypeScript","path":"chto takoe typescript"},{"name":"История TypeScript","path":"istoriya typescript"},{"name":"Для чего нужен TypeScript","path":"dlya chego nujen typescript"},{"name":"Зачем разработчику TypeScript","path":"zachem razrabotchiku typescript"}]},{"name":"Вступление","path":"vstuplenie","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"sistema tipov, tip dannyh, znachimye i ssylochnye tipy","sections":[{"name":"Экскурс в типизацию — система типов, тип данных, значимые и ссылочные типы","path":"ekskurs v tipizaciu — sistema tipov, tip dannyh, znachimye i ssylochnye tipy"},{"name":"Система Типов","path":"sistema tipov"},{"name":"Тип данных (тип)","path":"tip dannyh (tip)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"tip dannyh, peredaushchiisya po znacheniu (primitivnyi tip)"},{"name":"Тип данных, передающийся по ссылке","path":"tip dannyh, peredaushchiisya po ssylke"},{"name":"Итоги","path":"itogi"}]},{"name":"Связывание, типизация, вывод типов","path":"svyazyvanie, tipizaciya, vyvod tipov","sections":[{"name":"Связывание (Binding)","path":"svyazyvanie (binding)"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"leksicheskii analiz (tokenizaciya - tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"sintaksicheskii analiz (razbor - parsing)"},{"name":"Семантический анализ","path":"semanticheskii analiz"},{"name":"Типизация","path":"tipizaciya"},{"name":"Вывод Типов (type inference)","path":"vyvod tipov (type inference)"},{"name":"Итоги","path":"itogi"}]},{"name":"Преобразование типов","path":"preobrazovanie tipov","sections":[{"name":"Экскурс в типизацию — Преобразование типов","path":"ekskurs v tipizaciu — preobrazovanie tipov"},{"name":"Неявные Преобразования","path":"neyavnye preobrazovaniya"},{"name":"Явные Преобразования","path":"yavnye preobrazovaniya"},{"name":"Итоги","path":"itogi"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"tipizirovannye i netipizirovannye yazyki programmirovaniya","sections":[{"name":"Экскурс в типизацию — Типизированные и нетипизированные языки программирования","path":"ekskurs v tipizaciu — tipizirovannye i netipizirovannye yazyki programmirovaniya"},{"name":"Нетипизированные языки","path":"netipizirovannye yazyki"},{"name":"Типизированные языки","path":"tipizirovannye yazyki"}]},{"name":"Статическая и динамическая типизация","path":"staticheskaya i dinamicheskaya tipizaciya","sections":[{"name":"Экскурс в типизацию — статическая и динамическая типизация","path":"ekskurs v tipizaciu — staticheskaya i dinamicheskaya tipizaciya"},{"name":"Статическая типизация (Static Typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"dinamicheskaya tipizaciya (dynamic typing)"},{"name":"Итоги","path":"itogi"}]},{"name":"Сильная и слабая типизация","path":"silnaya i slabaya tipizaciya","sections":[{"name":"Экскурс в типизацию — Сильная и слабая типизация","path":"ekskurs v tipizaciu — silnaya i slabaya tipizaciya"},{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Слабая типизация (weakly typed)","path":"slabaya tipizaciya (weakly typed)"},{"name":"Итог","path":"itog"}]},{"name":"Явная и неявная типизация","path":"yavnaya i neyavnaya tipizaciya","sections":[{"name":"Экскурс в типизацию — явная и неявная типизация","path":"ekskurs v tipizaciu — yavnaya i neyavnaya tipizaciya"},{"name":"Явная типизация (explicit typing)","path":"yavnaya tipizaciya (explicit typing)"},{"name":"Неявная типизация (implicit typing)","path":"neyavnaya tipizaciya (implicit typing)"},{"name":"Итог","path":"itog"}]},{"name":"Совместимость типов на основе вида типизации","path":"sovmestimost tipov na osnove vida tipizacii","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"sovmestimost tipov (types compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"nominativnaya tipizaciya (nominative typing)"},{"name":"Структурная Типизация (structural typing)","path":"strukturnaya tipizaciya (structural typing)"},{"name":"Утиная Типизация (Duck typing)","path":"utinaya tipizaciya (duck typing)"},{"name":"Итоги","path":"itogi"}]},{"name":"Совместимость типов на основе вариантности","path":"sovmestimost tipov na osnove variantnosti","sections":[{"name":"Совместимость типов на основе вариантности","path":"sovmestimost tipov na osnove variantnosti"},{"name":"Иерархия наследования","path":"ierarhiya nasledovaniya"},{"name":"Ковариантность","path":"kovariantnost"},{"name":"Контравариантность","path":"kontravariantnost"},{"name":"Инвариантность","path":"invariantnost"},{"name":"Бивариантность","path":"bivariantnost"}]},{"name":"Аннотация Типов","path":"annotaciya tipov","sections":[{"name":"Аннотация Типов - общее","path":"annotaciya tipov - obshchee"},{"name":"Аннотация типа","path":"annotaciya tipa"},{"name":"Синтаксические конструкции var, let, const","path":"sintaksicheskie konstrukcii var, let, const"},{"name":"Функции (function)","path":"funkcii (function)"},{"name":"Стрелочные Функции (arrow function)","path":"strelochnye funkcii (arrow function)"},{"name":"Классы (class)","path":"klassy (class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"sravnenie sintaksisa typescript i javascript"},{"name":"Итог","path":"itog"}]},{"name":"Базовый Тип Any","path":"bazovyi tip any","sections":[{"name":"Базовый Тип Any","path":"bazovyi tip any"},{"name":"Any (any) произвольный тип","path":"any (any) proizvolnyi tip"},{"name":"Итог","path":"itog"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"primitivnye tipy number, string, boolean, symbol, bigint","sections":[{"name":"Важно","path":"vajno"},{"name":"Number (number) примитивный числовой тип","path":"number (number) primitivnyi chislovoi tip"},{"name":"String (string) примитивный строковый тип","path":"string (string) primitivnyi strokovyi tip"},{"name":"Boolean (boolean) примитивный логический тип","path":"boolean (boolean) primitivnyi logicheskii tip"},{"name":"Symbol (symbol) примитивный символьный тип","path":"symbol (symbol) primitivnyi simvolnyi tip"},{"name":"BigInt (bigint) примитивный числовой тип","path":"bigint (bigint) primitivnyi chislovoi tip"},{"name":"Итог","path":"itog"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"primitivnye tipy null, undefined, void, never, unknown","sections":[{"name":"Важно","path":"vajno"},{"name":"Null (null) примитивный null тип","path":"null (null) primitivnyi null tip"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"undefined (undefined) primitivnyi neopredelennyi tip"},{"name":"Void (void) отсутствие конкретного типа","path":"void (void) otsutstvie konkretnogo tipa"},{"name":"Never (never) примитивный тип","path":"never (never) primitivnyi tip"},{"name":"Unknown (unknown)","path":"unknown (unknown)"}]},{"name":"Примитивный Тип Enum","path":"primitivnyi tip enum","sections":[{"name":"Примитивный Тип Enum","path":"primitivnyi tip enum"},{"name":"Enum (enum) примитивный перечисляемый тип","path":"enum (enum) primitivnyi perechislyaemyi tip"},{"name":"Перечисления с числовым значением","path":"perechisleniya s chislovym znacheniem"},{"name":"Перечисления со строковым значением","path":"perechisleniya so strokovym znacheniem"},{"name":"Смешанное перечисление (mixed enum)","path":"smeshannoe perechislenie (mixed enum)"},{"name":"Перечисление в качестве типа данных","path":"perechislenie v kachestve tipa dannyh"},{"name":"Перечисление const с числовым и строковым значением","path":"perechislenie const s chislovym i strokovym znacheniem"},{"name":"Итог","path":"itog"}]},{"name":"Типы - Union, Intersection","path":"tipy - union, intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"tip obedinenie (union types)"},{"name":"Тип Пересечение (Intersection Type)","path":"tip peresechenie (intersection type)"},{"name":"Итоги","path":"itogi"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"type queries (zaprosy tipa), alias (psevdonimy tipa)","sections":[{"name":"Запросы Типа (Type Queries)","path":"zaprosy tipa (type queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"psevdonimy tipov (type aliases)"},{"name":"Итоги","path":"itogi"}]},{"name":"Примитивные литеральные типы Number, String, Boolean, Unique Symbol, Enum","path":"primitivnye literalnye tipy number, string, boolean, unique symbol, enum","sections":[{"name":"Примитивные типы — литеральные типы Number, String, Boolean, Unique Symbol, Enum","path":"primitivnye tipy — literalnye tipy number, string, boolean, unique symbol, enum"},{"name":"Литеральный тип Number (Numeric Literal Types)","path":"literalnyi tip number (numeric literal types)"},{"name":"Литеральный тип String (String Literal Types)","path":"literalnyi tip string (string literal types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"literalnyi tip boolean (boolean literal types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"literalnyi tip unique symbol (unique symbol) unikalnyi simvolnyi tip"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"literalnyi tip enum (enum literal types)"},{"name":"Итоги","path":"itogi"}]},{"name":"Object, Array, Tuple","path":"object, array, tuple","sections":[{"name":"Типы — Object, Array, Tuple","path":"tipy — object, array, tuple"},{"name":"Object (object) — ссылочный объектный тип","path":"object (object) — ssylochnyi obektnyi tip"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"array (type[]) ssylochnyi massivopodobnyi tip"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"tuple ([t0, t1, …, tn]) tip kortej"},{"name":"Итоги","path":"itogi"}]},{"name":"Function, Functional Types","path":"function, functional types","sections":[{"name":"Function, Functional Types","path":"function, functional types"},{"name":"Function Types - тип функция","path":"function types - tip funkciya"},{"name":"Functional Types - функциональный тип","path":"functional types - funkcionalnyi tip"},{"name":"this в сигнатуре функции","path":"this v signature funkcii"},{"name":"Итог","path":"itog"}]},{"name":"Interfaces","path":"interfaces","sections":[{"name":"Общая теория","path":"obshchaya teoriya"},{"name":"Интерфейс в TypeScript","path":"interfeis v typescript"},{"name":"Объявление (declaration)","path":"obyavlenie (declaration)"},{"name":"Конвенции именования интерфейсов","path":"konvencii imenovaniya interfeisov"},{"name":"Реализация интерфейса (implements)","path":"realizaciya interfeisa (implements)"},{"name":"Декларация свойств get и set (accessors)","path":"deklaraciya svoistv get i set (accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"ukazanie interfeisa v kachestve tipa (interface types)"},{"name":"Расширение интерфейсов (extends interface)","path":"rasshirenie interfeisov (extends interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"rasshirenie interfeisom klassa (extends class)"},{"name":"Описание класса (функции-конструктора)","path":"opisanie klassa (funkcii-konstruktora)"},{"name":"Описание функционального выражения","path":"opisanie funkcionalnogo vyrajeniya"},{"name":"Описание индексных членов в объектных типов","path":"opisanie indeksnyh chlenov v obektnyh tipov"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"inlain interfeisy (inline interface)"},{"name":"Слияние интерфейсов","path":"sliyanie interfeisov"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)","sections":[{"name":"Типы — Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"tipy — obektnye tipy s indeksnymi chlenami (obektnyi tip s dinamicheskimi kluchami)"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)","sections":[{"name":"Модификаторы доступа (Access Modifiers)","path":"modifikatory dostupa (access modifiers)"},{"name":"Модификатор доступа public (публичный)","path":"modifikator dostupa public (publichnyi)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"modifikator dostupa private (zakrytyi ili skrytyi)"},{"name":"Модификатор доступа protected (защищенный)","path":"modifikator dostupa protected (zashchishchennyi)"},{"name":"Модификаторы доступа и конструкторы класса","path":"modifikatory dostupa i konstruktory klassa"},{"name":"Быстрое объявление полей","path":"bystroe obyavlenie polei"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript","sections":[{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"zakrytye polya opredelennye specifikaciei ecmascript"}]},{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)","sections":[{"name":"Абстрактные классы (abstract classes)","path":"abstraktnye klassy (abstract classes)"},{"name":"Общие характеристики","path":"obshchie harakteristiki"},{"name":"Теория","path":"teoriya"}]},{"name":"Полиморфный тип this","path":"polimorfnyi tip this","sections":[{"name":"Полиморфный тип this","path":"polimorfnyi tip this"}]},{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)","sections":[{"name":"Модификатор readonly (только для чтения)","path":"modifikator readonly (tolko dlya chteniya)"}]},{"name":"Definite Assignment Assertion Modifier","path":"definite assignment assertion modifier","sections":[{"name":"Классы — Definite Assignment Assertion Modifier","path":"klassy — definite assignment assertion modifier"}]},{"name":"Классы — Тонкости","path":"klassy — tonkosti","sections":[{"name":"Классы — Тонкости","path":"klassy — tonkosti"},{"name":"Классы - Тонкости implements","path":"klassy - tonkosti implements"},{"name":"Частичное Слияние интерфейса с классом","path":"chastichnoe sliyanie interfeisa s klassom"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"pereopredelenie svoistv polyami i naoborot pri nasledovanii"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov","sections":[{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"razlichiya var, let, const i modifikatora readonly pri neyavnom ukazanii primitivnyh tipov"},{"name":"Итог","path":"itog"}]},{"name":"Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"optional, not-null, not-undefined, definite assignment assertion","sections":[{"name":"Операторы — Optional, Not-Null, Not-Undefined, Definite Assignment Assertion","path":"operatory — optional, not-null, not-undefined, definite assignment assertion"},{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"neobyazatelnye polya, parametry i metody (optional fields, parameters and methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"operator ! (non-null and non-undefined operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"operator ! (definite assignment assertion)"},{"name":"Итог","path":"itog"}]},{"name":"Обобщения (Generics)","path":"obobshcheniya (generics)","sections":[{"name":"Обобщения - общие понятия","path":"obobshcheniya - obshchie ponyatiya"},{"name":"Обобщения в TypeScript","path":"obobshcheniya v typescript"},{"name":"Параметры типа - extends (generic constraints)","path":"parametry tipa - extends (generic constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"parametra tipa - znachenie po umolchaniu = (generic parameter defaults)"},{"name":"Параметры типа - как тип данных","path":"parametry tipa - kak tip dannyh"}]},{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)","sections":[{"name":"Дискриминантное Объединения (Discriminated Union)","path":"diskriminantnoe obedineniya (discriminated union)"}]},{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa","sections":[{"name":"Импорт и экспорт только типа","path":"import i eksport tolko tipa"}]},{"name":"Утверждение Типов (Type Assertion)","path":"utverjdenie tipov (type assertion)","sections":[{"name":"Утверждение Типов - общее","path":"utverjdenie tipov - obshchee"},{"name":"Утверждение Типа `<Type>` синтаксис","path":"utverjdenie tipa `<type>` sintaksis"},{"name":"Утверждение Типа с помощью оператора as","path":"utverjdenie tipa s pomoshchu operatora as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"privedenie (utverjdenie) k konstante (const assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"utverjdenie v signature (signature assertion)"},{"name":"Итоги","path":"itogi"}]},{"name":"Защитники типа","path":"zashchitniki tipa","sections":[{"name":"Защитники Типа - общее","path":"zashchitniki tipa - obshchee"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"sujenie diapazona mnojestva tipov na osnove tipa dannyh"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"sujenie diapazona mnojestva tipov na osnove priznakov prisushchih tipu tagged union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"sujenie diapazona mnojestva tipov na osnove dostupnyh chlenov obekta"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"sujenie diapazona mnojestva tipov na osnove funkcii, opredelennoi polzovatelem"}]},{"name":"Вывод типов","path":"vyvod tipov","sections":[{"name":"Вывод типов - общие сведения","path":"vyvod tipov - obshchie svedeniya"},{"name":"Вывод примитивных типов","path":"vyvod primitivnyh tipov"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"vyvod primitivnyh tipov dlya konstant (const) i polei tolko dlya chteniya (readonly)"},{"name":"Вывод объектных типов","path":"vyvod obektnyh tipov"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"vyvod tipa dlya polei klassa na osnove inicializacii ih v konstruktore"},{"name":"Вывод объединенных (Union) типов","path":"vyvod obedinennyh (union) tipov"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"vyvod peresecheniya (intersection) s diskriminantnymi polyami"},{"name":"Вывод типов кортеж (Tuple)","path":"vyvod tipov kortej (tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"sovmestimost obektnyh tipov (compatible object types)","sections":[{"name":"Важно","path":"vajno"},{"name":"Совместимость объектных типов в TypeScript","path":"sovmestimost obektnyh tipov v typescript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"sovmestimost funkcionalnyh tipov (compatible function types)","sections":[{"name":"важно","path":"vajno"},{"name":"Совместимость параметров","path":"sovmestimost parametrov"},{"name":"Совместимость возвращаемого значения","path":"sovmestimost vozvrashchaemogo znacheniya"}]},{"name":"Совместимость объединений (Union Types)","path":"sovmestimost obedinenii (union types)","sections":[{"name":"Совместимость","path":"sovmestimost"}]},{"name":"Типизация в TypeScript","path":"tipizaciya v typescript","sections":[{"name":"Общие сведения","path":"obshchie svedeniya"},{"name":"Статическая типизация (static typing)","path":"staticheskaya tipizaciya (static typing)"},{"name":"Сильная типизация (strongly typed)","path":"silnaya tipizaciya (strongly typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"yavno tipizirovannyi (explicit typing) s vyvodom tipov (type inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"sovmestimost tipov (type compatibility), strukturnaya tipizaciya (structural typing)"},{"name":"Вариантность (variance)","path":"variantnost (variance)"},{"name":"Наилучший общий тип (Best common type)","path":"nailuchshii obshchii tip (best common type)"},{"name":"Контекстный тип (Contextual Type)","path":"kontekstnyi tip (contextual type)"},{"name":"Итог","path":"itog"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -","sections":[{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"operator keyof, lookup types, mapped types, mapped types - prefiksy + i -"},{"name":"Запрос ключей keyof","path":"zapros kluchei keyof"},{"name":"Поиск типов (Lookup Types)","path":"poisk tipov (lookup types)"},{"name":"Сопоставление типов (Mapped Types)","path":"sopostavlenie tipov (mapped types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"prefiksy + i - v sopostavlennyh tipah"}]},{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)","sections":[{"name":"Условные типы (Conditional Types)","path":"uslovnye tipy (conditional types)"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"raspredelitelnye uslovnye tipy (distributive conditional types)"},{"name":"Вывод типов в условном типе","path":"vyvod tipov v uslovnom tipe"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"readonly, partial, required, pick, record","sections":[{"name":"Расширенные типы — Readonly, Partial, Required, Pick, Record","path":"rasshirennye tipy — readonly, partial, required, pick, record"},{"name":"Readonly","path":"readonly"},{"name":"Partial","path":"partial"},{"name":"Required","path":"required"},{"name":"Pick","path":"pick"},{"name":"Record","path":"record"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"exclude, extract, nonnullable, returntype, instancetype, omit","sections":[{"name":"Расширенные типы — Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"rasshirennye tipy — exclude, extract, nonnullable, returntype, instancetype, omit"},{"name":"Exclude","path":"exclude"},{"name":"Extract","path":"extract"},{"name":"NonNullable","path":"nonnullable"},{"name":"ReturnType","path":"returntype"},{"name":"InstanceType","path":"instancetype"},{"name":"Parameters","path":"parameters"},{"name":"ConstructorParameters","path":"constructorparameters"},{"name":"Тип Omit","path":"tip omit"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"massivopodobnye readonly tipy, readonlyarray, readonlymap, readonlyset","sections":[{"name":"Массивоподобные readonly типы","path":"massivopodobnye readonly tipy"},{"name":"ReadonlyArray","path":"readonlyarray"},{"name":"ReadonlyMap","path":"readonlymap"},{"name":"ReadonlySet","path":"readonlyset"}]},{"name":"Синтаксические конструкции и операторы","path":"sintaksicheskie konstrukcii i operatory","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"operatory prisvaivaniya korotkogo zamykaniya (&&=, ||=, &&=)"},{"name":"Операнды для delete должны быть необязательными","path":"operandy dlya delete doljny byt neobyazatelnymi"}]},{"name":"React - расширение .tsx","path":"react - rasshirenie .tsx","sections":[{"name":"React — расширение .tsx","path":"react — rasshirenie .tsx"}]},{"name":"Функциональные компоненты","path":"funkcionalnye komponenty","sections":[{"name":"Определение компонента как Function Declaration","path":"opredelenie komponenta kak function declaration"},{"name":"Определение компонента как Function Expression","path":"opredelenie komponenta kak function expression"}]},{"name":"Классовые компоненты","path":"klassovye komponenty","sections":[{"name":"React — производные от Component","path":"react — proizvodnye ot component"},{"name":"React - производные от PureComponent","path":"react - proizvodnye ot purecomponent"}]},{"name":"Универсальные компоненты","path":"universalnye komponenty","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"obobshchennye komponenty (generics component)"}]},{"name":"Типизированные хуки","path":"tipizirovannye huki","sections":[{"name":"Предопределенные хуки","path":"predopredelennye huki"},{"name":"Пользовательский хук","path":"polzovatelskii huk"}]},{"name":"Контекст (Context)","path":"kontekst (context)","sections":[{"name":"Определение контекста","path":"opredelenie konteksta"}]},{"name":"HOC (Higher-Order Components)","path":"hoc (higher-order components)","sections":[{"name":"Определение hoc","path":"opredelenie hoc"},{"name":"Определение hoc на основе функционального компонента","path":"opredelenie hoc na osnove funkcionalnogo komponenta"},{"name":"Определение hoc на основе классового компонента","path":"opredelenie hoc na osnove klassovogo komponenta"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"prostranstva imen (namespace) i moduli (module)","sections":[{"name":"Namespace и module — предназначение","path":"namespace i module — prednaznachenie"},{"name":"Namespace - определение","path":"namespace - opredelenie"},{"name":"Модули (export, import) — определение","path":"moduli (export, import) — opredelenie"},{"name":"Конфигурирование проекта","path":"konfigurirovanie proekta"}]},{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya","sections":[{"name":"Настройка рабочего окружения","path":"nastroika rabochego okrujeniya"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"sborka proekta s pomoshchu tsc (typescript compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"sborka s ispolzovaniem ssylok na proekty","sections":[{"name":"Ссылки на проекты","path":"ssylki na proekty"}]},{"name":"Декларации","path":"deklaracii","sections":[{"name":"Что такое декларация (Declaration)","path":"chto takoe deklaraciya (declaration)"},{"name":"Установка деклараций с помощью @types","path":"ustanovka deklaracii s pomoshchu @types"},{"name":"Подготовка к созданию декларации","path":"podgotovka k sozdaniu deklaracii"},{"name":"Разновидности деклараций","path":"raznovidnosti deklaracii"},{"name":"Декларации и область видимости","path":"deklaracii i oblast vidimosti"},{"name":"Декларации для библиотек с одной точкой входа","path":"deklaracii dlya bibliotek s odnoi tochkoi vhoda"},{"name":"Декларации для библиотек с множеством точек входа","path":"deklaracii dlya bibliotek s mnojestvom tochek vhoda"},{"name":"Создание деклараций вручную","path":"sozdanie deklaracii vruchnuu"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"direktiva s troinym sleshem (triple-slash directives)"},{"name":"Импортирование декларации (import)","path":"importirovanie deklaracii (import)"}]},{"name":"Публикация","path":"publikaciya","sections":[{"name":"Публикация","path":"publikaciya"}]},{"name":"Опции компилятора","path":"opcii kompilyatora","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressexcesspropertyerrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressimplicitanyindexerrors"},{"name":"noImplicitAny","path":"noimplicitany"},{"name":"checkJs","path":"checkjs"},{"name":"JSX","path":"jsx"},{"name":"jsxFactory","path":"jsxfactory"},{"name":"target (t)","path":"target (t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysstrict"},{"name":"strictNullChecks","path":"strictnullchecks"},{"name":"stripInternal","path":"stripinternal"},{"name":"noImplicitThis","path":"noimplicitthis"},{"name":"noImplicitUseStrict","path":"noimplicitusestrict"},{"name":"baseUrl","path":"baseurl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootdir"},{"name":"rootDirs","path":"rootdirs"},{"name":"traceResolution","path":"traceresolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"nolib"},{"name":"noResolve","path":"noresolve"},{"name":"noStrictGenericChecks","path":"nostrictgenericchecks"},{"name":"preserveConstEnums","path":"preserveconstenums"},{"name":"removeComments","path":"removecomments"},{"name":"noUnusedLocals","path":"nounusedlocals"},{"name":"noUnusedParameters","path":"nounusedparameters"},{"name":"skipLibCheck","path":"skiplibcheck"},{"name":"declarationDir","path":"declarationdir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeroots"},{"name":"allowUnusedLabels","path":"allowunusedlabels"},{"name":"noImplicitReturns","path":"noimplicitreturns"},{"name":"noFallthroughCasesInSwitch","path":"nofallthroughcasesinswitch"},{"name":"outFile","path":"outfile"},{"name":"allowSyntheticDefaultImports","path":"allowsyntheticdefaultimports"},{"name":"allowUnreachableCode","path":"allowunreachablecode"},{"name":"allowJs","path":"allowjs"},{"name":"reactNamespace","path":"reactnamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleresolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noemithelpers"},{"name":"newLine","path":"newline"},{"name":"inlineSourceMap","path":"inlinesourcemap"},{"name":"inlineSources","path":"inlinesources"},{"name":"noEmitOnError","path":"noemitonerror"},{"name":"noEmit","path":"noemit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downleveliteration"},{"name":"emitBOM","path":"emitbom"},{"name":"emitDecoratorMetadata","path":"emitdecoratormetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceconsistentcasinginfilenames"},{"name":"help (h)","path":"help (h)"},{"name":"importHelpers","path":"importhelpers"},{"name":"isolatedModules","path":"isolatedmodules"},{"name":"listEmittedFiles","path":"listemittedfiles"},{"name":"listFiles","path":"listfiles"},{"name":"sourceRoot","path":"sourceroot"},{"name":"mapRoot","path":"maproot"},{"name":"maxNodeModuleJsDepth","path":"maxnodemodulejsdepth"},{"name":"project (p)","path":"project (p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version (v)"},{"name":"watch (w)","path":"watch (w)"},{"name":"preserveSymlinks","path":"preservesymlinks"},{"name":"strictFunctionTypes","path":"strictfunctiontypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctpropertyinitialization"},{"name":"esModuleInterop","path":"esmoduleinterop"},{"name":"emitDeclarationsOnly","path":"emitdeclarationsonly"},{"name":"resolveJsonModule","path":"resolvejsonmodule"},{"name":"declarationMap","path":"declarationmap"},{"name":"strictBindCallApply","path":"strictbindcallapply"},{"name":"showConfig","path":"showconfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsbuildinfofile"},{"name":"allowUmdGlobalAccess","path":"allowumdglobalaccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disablesourceofprojectreferenceredirect"},{"name":"useDefineForClassFields","path":"usedefineforclassfields"},{"name":"importsNotUsedAsValues","path":"importsnotusedasvalues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumechangesonlyaffectdirectdependencies"},{"name":"watchFile","path":"watchfile"},{"name":"watchDirectory","path":"watchdirectory"},{"name":"fallbackPolling","path":"fallbackpolling"},{"name":"synchronousWatchDirectory","path":"synchronouswatchdirectory"}]}]}},"staticQueryHashes":["408059355","63159454"]}