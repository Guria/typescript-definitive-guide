# Различия var, let, const и модификатора readonly при неявном указании примитивных типов
## Различия var, let, const и модификатора readonly при неявном указании примитивных типов


После того, как было рассмотрено понятие *литеральных типов*, и тем самым подведена черта под примитивными типами, наступило время рассмотреть особенности `var`, `let` и `const` для которых типы указываются неявно.

Неявное указание типов означает, что тип будет определен с помощью вывода типов. В тот момент, когда `var` или `let` объявляется, но не инициализируется, вывод типов определяет их принадлежность к типу `any`. В случае с `const` невозможно обойтись без инициализации в момент объявления.

~~~~~typescript
var a; // a: any
let b; // b: any
const c; // Error
~~~~~

Если `var` или `let` была инициализирована в момент объявления и при этом тип данных не был указан явно, вывод типов определит их принадлежность к типу, к которому относятся их значения.

~~~~~typescript
var a = 5; // a: number
let b = 'text'; // b: string
~~~~~

Но в случае с `const`, которому присвоено примитивное значение, вывод типов определит принадлежность не к типу значения, а к литеральному типу.

~~~~~typescript
const a = 5; // a: 5
const b = 'text'; b: 'text'
~~~~~

Поле, объявленное с использованием модификатора `readonly`, имеет поведение, идентичное `const`. 

~~~~~typescript
class T1 {
    readonly f1 = 'text'; // f1: text
    readonly f2 = 0; // f2: 0
    readonly f3 = true; // f3: true
}
~~~~~

Более подробно эта тема рассматривается далее, в главе [“Вывод типов”](../037.(Типизация)%20Вывод%20типов).

## Итог

- При инициализации значением, принадлежащем к примитивному типу, для `var` и `let` вывод типов укажет принадлежность к типу, к которому относится их значение.
- В случае, когда примитивным значением будет инициализирована `const`, вывод типов укажет её принадлежность к литеральному типу, в основе которого будет лежать само значение.
- Правило вывода типа для констант верно и для полей и свойств, помеченных модификатором `readonly`.
