# HOC (Higher-Order Components)

Настало время рассмотреть со всех сторон механизм предназначенный для расширения функциональных возможностей компонента с помощью компонента-обертки обозначаемого как _Higher-Order Components_ или сокращенно _HOC_.


## Определение hoc

При разработке React приложений очень часто разработчикам приходится создавать конструкцию, известную в *react*-сообществе, как *HOC* (*Higher-Order Components*).

*HOC* — это функция, которая принимает один компонент и возвращает новый. Другими словами, *hoc* — это функция, ожидающая в качестве параметров компонент (назовем его входным), который оборачивается в другой, объявленный в теле функции, компонент, который выступает в роли возвращаемого из функции значения (назовем его выходным). Слово “оборачивание”,  применимое относительно компонентов, означает, что один компонент отрисовывает (рендерит) другой компонент, со всеми вытекающими из этого процесса (проксирования). За счет того, что входной компонент оборачивается в выходной, достигается расширение его и/или общего функционала. Кроме того, это позволяет устанавливать входному компоненту как зависимости, так и данные, полученные из внешних сервисов.


## Определение hoc на основе функционального компонента

В качестве примера реализуем сценарий при котором пропсы _компонента обертки_ определяемого в теле _hoc_ разделяются на две категории. Первая необходима исключительно самому компоненту-обертке для генерации новых пропсов, которые в дальнейшем будут объединены с пропсами относящихся ко второй категирии и установлены _оборачиваемому компоненту_. 

Начать стоит с детального рассмотрения сигнатуры универсальной функции, которая в качестве единственного параметра типа ожидает тип `WrappedProps` представляющий пропсы предназначенные исключительно оборачиваемому-компоненту ссылка на который доступна через единственный параметр `WrappedComponent`. `WrappedComponent` может принадлежать как к функциональному `FC<T>` так и классовому типу `ComponentClass<T>` пропсы которого помимо типа представленного аргументом типа `WrappedProps` должны принадлежать ещё и к типу `WrapperForWrappedProps` описывающего знчения создаваемые у устанавливаемые компонентом-оберткой. Поскольку в нашем конкретном примере _фнкция hoc_ в качестве компонента-обертки определяет функциональный компонент, тип возвращаемого значения указан соответствующим образом `FC<T>`. Пропсы компонента-обертки должны принадлежать к нескольким типам одновременно поскольку для его работы требуются не только пропсы необходимые исключительно ему (`WrapperProps`), но и пропсы которые он лишь пробрасывает оборачиваемому-компоненту (`WrappedProps`). Поэтому аргумент типа представляющего возращаемое значение является типом пересечение `WrappedProps & WrapperProps`.


`````typescript
import React, {FC, ComponentClass} from "react";


/**[0] */
export interface WrapperProps {
    a: number;
    b: string;
}
/**[1] */
export interface WrapperForWrappedProps {
    c: boolean;
}

/**
 * [0] WrapperProps описывает данные необходимые
 * исключительно компоненту-обертке определяемому
 * внутри функции hoc, который генерирует
 * и устанавливает данные принадлежащие к типу 
 * WrapperForWrappedProps [1] обертываемому-компоненту.
 */


                /**[2]      [3] */
export function withHoc<WrappedProps>(
        /**[4]        [5]      [6]              [7]                     [8]           [6]                 [7] */
    WrappedComponent: FC<WrappedProps & WrapperForWrappedProps> | ComponentClass<WrappedProps & WrapperForWrappedProps>)
       /**[9]    [10]           [11] */
        : FC<WrappedProps & WrapperProps>

/**
 * [2] определение универсальной функции hoc
 * чей единственный параметр типа WrappedProps [3]
 * представляет часть пропсов обертываемого-компонента, а их оставшаяся часть, генерируемая
 * компонентом-оберткой определенным в теле hoc, к типу WrapperForWrappedProps.
 * 
 * Единственный параметр hoc WrappedComponent [4] принадлежит
 * к типу объединение состоящему из типов функционального [5] и классового [8] компонента
 * котором в качестве аргумента типа установлен тип пересечение определяемый типами WrappedProps [6]
 * и WrapperForWrappedProps [7].
 * 
 * Тип возвращаемого hoc значения обозначен как функциональный компонент [9] который по мимо пропсов
 * устанавливаемых разработчиком и прокидываемых компонентом-оберткой WrappedProps [10] ожидает ещё и пропсы
 * генерируемые и устанавливаемые компонентом-оберткой [11].
 * 
 * [!] принадлежность возращаемого hoc значения к функциональному типу указана лишь по причине того
 * что в нашем пример hoc возвращает именно его, а не классовый компонент. 
 */
`````

Поскольку пример является минималистическим реализация тела _hoc_ будет включать в себя лишь определение компонента-обертки выступающего в качестве возвращаемого значение. Тип компонента-обертки принадлежит к функциональному компоненту пропсы которого должны соответствовать типам описывающих как пропсы необходимые исключительно самому компоненту-обертке, так и оборачиваемому-компоненту. В теле комопнента-обертки происходит разделение полученных пропсов на две части. Одна предназначается исключительно самому компоненту-обертке и служит для определения значений предназначенных для объединения со второй частью. Объединенные значения устанавливаются в качестве пропсов оборачиваемому-компоненту ссылка на который доступна через единственный параметр функции _hoc_. Стоит обратить внимание что поскольку вторая часть пропсов образуется как остаточные параметры полученные при деструктуризации, то их тип принадлежит к типу `Pick<T, K>`, который для совместимости с типом описывающим прокидываемые компонентом-оберткой пропсы необходимо сначала привести к типу `unknown`, а уже затем к конкретному типу `WrappedProps`.


`````typescript
import React, {FC, ComponentClass} from "react";


export interface WrapperProps {
    a: number;
    b: string;
}
export interface WrapperForWrappedProps {
    c: boolean;
}

export function withHoc<WrappedProps>(
    WrappedComponent: FC<WrappedProps & WrapperForWrappedProps> | ComponentClass<WrappedProps & WrapperForWrappedProps>)
        : FC<WrappedProps & WrapperProps> {

                    /**[0]         [1]    [2]             [3] */
            const WrapperComponent:FC<WrappedProps & WrapperProps> = props => {
                  /**[4]            [5] */
                let {a, b, ...wrappedOnlyProps} = props;
                        /**[6] */
                let wrapperToWrappedProps = {
                    c: true
                };
                       /**[7]                      [8]                     [9]            [10]         [11] */
                let wrappedFullProps = {...wrapperToWrappedProps, ...wrappedOnlyProps as unknown as WrappedProps};

                            /**[12]               [13] */
                return <WrappedComponent {...wrappedFullProps} />
            }

                    /**[14] */
            return WrapperComponent;
}

/**
 * [0] определение комопнента-обертки принадлежащего
 * к типу функционального компонента [1] пропсы которого
 * одновременно принадлежат к типам описывающих пропсы предназначаемые
 * исключиетельно обертываемому-компоненту WrappedProps [2] и исключительно
 * компоненту-обертке WrapperProps [3]. В теле комопнента-обертки общие пропсы
 * разделяются с помощью механизма дествруктуризации на две категории, первая из
 * которых прдназначается самому компоненту-обертке [4], а вторая оборачиваемому-компоненту [5].
 * Поскольку пропсы пердназначенные оборачиваемому-компоненту [5] представляют из себя остаточные значения
 * полученные при деструктуризации, они принадлежат к типу Pick<T, K> что требует перед объединением их [9]
 * с пропсами созданными компонентом-оберткой [8] сначала к типу unknown [10], а затем уже к необходимому 
 * WrappedProps [11]. После этого слитые воедино пропсы можно устанавливать [13] компоненту [12] ссылка на который
 * доступна в качестве едлинственного параметра hoc.
 * 
 * [14] возвращаем из hoc компонент-обертку.
 */
`````

Теперь необходимо определить компонент пропсы которого будут принадледать к типам описывающих значения установка которых разделена между разработчиком и комопнентом-оберткой. Далее этот комопнент необходимо передать в качестве аргумента созданному нами _hoc_ возвращаемое значение которого является комопнентом-оберткой с которым и будет взаимодействовать разработчик. Осталось создать экземпляр компонента-обертки и убедится как сила типизации позволяет установить в качестве пропсов только необходимые значения.

`````typescript
/**[0] */
export interface CustomCompoenntProps {
    d: number;
    e: string;
}

                /**[1]                  [2]                     [3]                [4] [5][5] */
export const CustomComponent: FC<CustomCompoenntProps & WrapperForWrappedProps> = ({c, d, e}) => {
    return null;
} 

                    /**[6]              [7]         [8] */
export const CustomComponentWrapped = withHoc(CustomComponent);

/**
 * [0] объявление типа CustomCompoenntProps представляющего пропсы предназначенные
 * для обертываемого-компонента [1] и установка которых является
 * задачей разработчика. Пропсы компонента-обертки представленного
 * функциональным компонентом помимо типа CustomCompoenntProps [2]
 * описывающего значения устанавливаемые разработчиком [5]
 * также принадлежат к типу WrapperForWrappedProps [3] описывающего
 * значения устанавливаемые компонентом-оберткой [4].
 * 
 * Ссылка на оборачиваемый-компонент передается в качестве аргумента [8]
 * функции hoc [7], а результат вызова сохраняется в переменную представляющую
 * компонент-обертку [8].
 */


                     /**[9]   [9]    [10]  [10] */
<CustomComponentWrapped a={0} b={``} d={1} e={``} />; // Ok
                     /**[9]   [9]    [11]     [10]  [10] */
<CustomComponentWrapped a={0} b={``} c={true} d={1} e={``} />; // Error -> Property 'c' does not exist on type CustomCompoenntProps & WrapperProps'

/**
 * При создании экземпляра компонента-обертки будет необходимо установить
 * параметры описываемые как типом WrapperProps [9] и так и CustomCompoenntProps [10].
 * При попытке установить иные значения выозникнет ошибка. 
 */
 `````


## Определение hoc на основе классового компонента


Поскольку пример для _hoc_ возвращающего в качестве комопнента-обертки классовый компонент отличается от предыдущего лишь заменой функции на класс и объявлением для него двух дополнительных типов `*State` и `*Snapshot`, в повторноем комментированиии происходящего попросту нет смысла.

`````typescript
import React, {FC, ComponentClass, Component} from "react";


export interface WrapperProps {
    a: number;
    b: string;
}

/**[0] */
interface WrapperState {}
/**[1] */
interface WrapperSnapshot {}

export interface WrapperForWrappedProps {
    c: boolean;
}


/**
 * Поскольку комопнент-обертка будет представлен
 * классовым компонентом помимо описания его *Props
 * также появляется необходимость в объявлении типов
 * описывающих его *State [0] и *Snapshot [1].
 */

/**
 * [!] Стоит обратить внимание что по причине
 * упрощенности примера отсутствуют более компактные
 * псевдонимы для менее компактных типов.
 */

export function withHoc<WrappedProps>(
    WrappedComponent: FC<WrappedProps & WrapperForWrappedProps> | ComponentClass<WrappedProps & WrapperForWrappedProps>)
        : ComponentClass<WrappedProps & WrapperProps> {

                    /**[2] */
            class WrapperComponent extends Component<WrapperProps & WrappedProps, WrapperState, WrapperSnapshot> {
                render() {
                    let {a, b, ...wrappedOnlyProps} = this.props;
                    let wrapperToWrappedProps = {
                        c: true
                    };
                    let wrappedFullProps = {...wrapperToWrappedProps, ...wrappedOnlyProps as unknown as WrappedProps};


                    return <WrappedComponent {...wrappedFullProps} />
                }
            }


            return WrapperComponent;
}

/**
 * [2] определение комопнента-обертки в виде классового компонента.
 */

export interface CustomCompoenntProps {
    d: number;
    e: string;
}

export const CustomComponent: FC<CustomCompoenntProps & WrapperForWrappedProps> = ({c, d, e}) => {
    return null;
} 

export const CustomComponentWrapped = withHoc(CustomComponent);


<CustomComponentWrapped a={0} b={``} d={1} e={``} />; // Ok
<CustomComponentWrapped a={0} b={``} c={true} d={1} e={``} />; // Error -> Property 'c' does not exist on type CustomCompoenntProps & WrapperProps'
`````
