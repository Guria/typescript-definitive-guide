# Настройка рабочего окружения

![Chapter Cover](./images/chapter-cover.png)

## Настройка рабочего окружения

Важным фактом является то, что насколько бы не была продуктивной работа создателей _TypeScript_, им не успеть за развитием всей индустрии, всего сообщества. Простыми словами, насколько бы не был продвинут компилятор, на практике его возможностей не хватает. Для того чтобы покрыть все потребности, разработчикам приходится прибегать к использованию сторонних библиотек, распространяемых через пакетный менеджер _npm_.

Кроме того _html_ и _css_ используют в чистом виде, по большей части, только в образовательных целях. В реальных проектах используют их более продвинутые аналоги, как например _jade_ или _sass_, которые также как _TypeScript_, нуждаются в компиляторах. Кроме того, приложения не обходятся без шрифтов, иконок и изображений, которые в целях оптимизации, также принято предварительно обрабатывать. Поэтому современный процесс разработки не представляется возможным без специализированных сборщиков, таких как _webpack_ или _gulp_.

Если последний относится к так называемым _task runner’ам_, при использовании которого, разработчик самостоятельно создает для каждого конкретного процесса уникальную задачу, самостоятельно настраивает отлов ошибок и самостоятельно создает композицию из получившихся задач. В свою очередь _webpack_, это настоящий комбайн, для которого нужно устанавливать требуемые для конкретного проекта плагины, которые затем нужно конфигурировать, указывая пути к тем или иным директориям.

Но так как книга посвящена языку _TypeScript_, то прежде всего, для большего понимания, нужно рассмотреть сборку проекта с помощью только одного компилятора _TypeScript_. Только прежде чем приступить стоит уточнить несколько важных деталей. Первое на что стоит обратить внимание, что все устанавливаемые модули устанавливаются в проект локально. Кроме того, все проделывается на операционной системе _Ubuntu_ на которой настроен _NodeJS_.

## Сборка проекта с помощью tsc (TypeScript compiler)

Первым делом нужно создать директорию, в данном случае это будет директория я с названием _typescript-with-tsc_, которая будут содержать две поддиректории _src_ и _dest_. В первой будут находится все исходные файлы с расширением _.ts_, а во второй будут размещаться преобразованные файлы с расширением _.js_.

Теперь нужно открыть консоль в рабочей директории и выполнить инициализацию _npm_, в данном случае ускоренную.

```typescript
npm init -y
```

На этот момент, в директории должен появится файл _package.json_. После инициализации npm, установим компилятор _TypeScript_, выполнив в консоли

```typescript
npm i -D typescript
```

После успешной установки прежде всего нужно конфигурировать _TypeScript_. Для этого нужно выполнить в консоли

```typescript
tsc init
```

Но так как _TypeScript_ установлен локально, следует указать полный путь.

```typescript
./node_modules/.bin/tsc --init
```

После этого в директории должен появится файл _tsconfig.json_, точную настройку которого можно произвести после прочтения главы посвященной опциям компилятора (глава [“Опции компилятора”]()), а пока просто укажем нужные настройки. В сгенерированном файле _tsconfig.json_ будет очень много опций, большинство из которых закомментировано, но в итоге должно получиться нечто подобное.

```typescript
{
"compilerOptions": {
  "target": "es5",
   "module": "system",
   "outFile": "./dest/build.js",
   "rootDir": "./src"
},
"exclude": [
  "/node_modules/"
]
}
```

Теперь можно приступить к _dev_ сборке. Для этого нужно открыть файл _package.json_ и в поле `script` прописать команды для пакетного менеджера _npm_.

```typescript
{
"name": "typescript-with-tsc",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
  "build": "./node_modules/.bin/tsc --project ./tsconfig.json --watch
",
  "test": "echo \"Error: no test specified\" && exit 1"
},
"author": "",
"license": "ISC",
"devDependencies": {
  "typescript": "^2.5.2"
}
}
```

Теперь осталось только создать в директории _src_ файл _index.ts_ и запустить процесс разработки выполнив в консоли

```typescript
npm run build
```

После этого в папке _dest_ должен появится скомпилированный _index.js_, а при изменении файлов в директории _src_, преобразование должно запускаться автоматически. Сразу стоит обратить внимание на то, как именно компилятор понимает что компилировать.

Для примера, создадим в директории _src_ файл _hello-world.ts_ в котором объявим функцию возвращающее приветствие.

```typescript
// Файл hello-world.ts

export function getMassage(): string {
    return 'Hello World!';
}
```

Важный момент заключается в том, что компилятор не будет обращать на этот файл внимание, пока он не будет задействован в программе.

```typescript
import { getMassage } from './hello-world';

console.log(getMassage()); // Hello World!
```

Такое поведение называется _Tree Shaking_ и если по каким-либо причинам его нужно переопределить, то для этого нужно поправить конфигурацию компилятора.

```typescript
{
"compilerOptions": {
  "target": "es5",
  "module": "system",
  "outFile": "./dest/build.js",
  "rootDir": "./src/"
},
"include": [
  "./src/**/*.ts"
],
"exclude": [
  "/node_modules/"
]
}
```

Очень часто бывает так, что при разработки в коде используются библиотеки, которых не должно быть в конечной сборке. Для этого можно было бы каждый раз переписывать конфигурационный файл _tsconfig.json_, но есть способ сделать это элегантнее.

Для того, чтобы разделить _dev_ сборку от _prod_ сборки, следует создать ещё один конфигурационный файл. Назовем его _tsconfig.prod.json_ и поместим его, также как и _dev_ конфигурационный файл, в корне проекта. Стоит добавить что конфигурационные файлы можно размещать где угодно, главное при запуске компилятора передавать ссылку на нужный конфигурационный файл с помощью опции `--project`. В случае если путь до конфигурационного файла не был указан, компилятор будет искать файл _tsconfig.json_ в той директории из под которой он был запущен.

```typescript
tsc
tsc --project ./tsconfig.json


// or

tsc --project ./tsconfig.props.json
```

После того, как конфигурационный файл был создан и в нем были установлены нужные опции, остается только создать команду для запуска _prod_ сборки. Для этого снова откройте файл _package.json_ и в свойстве `script` укажите команду для запуска компиляции, только на этот раз укажите путь до _tsconfig.prod.json_. Единственное на что стоит обратить внимание, что при финальной сборке не нужно указывать опцию `--watch`, которая говорит компилятору, что нужно отслеживать изменения в файлах и запускать сборку автоматически.

```typescript
{
"name": "typescript-with-tsc",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
  "build": "./node_modules/.bin/tsc --project ./tsconfig.json --watch",
  "build:prod": "./node_modules/.bin/tsc --project ./tsconfig.prod.json",
  "test": "echo \"Error: no test specified\" && exit 1"
},
"author": "",
"license": "ISC",
"devDependencies": {
  "@types/react": "^16.0.5",
  "@types/react-dom": "^15.5.4",
  "react": "^15.6.1",
  "react-dom": "^15.6.1",
  "typescript": "^2.5.2"
}
}
```

Чтобы запустить такую сборку нужно, как и прежде, выполнить команду в терминале, только на этот раз указать другое имя.

```typescript
npm run build:prod
```

Также не будет лишним упомянуть, что в реальных проектах, практически всегда изобилуют множеством конфигурационных файлов. Поэтому если у Вас возникает мысль, что один конфигурационный файл не удовлетворяет условия нескольких сборок, даже не раздумывайте, сразу создавайте отдельный конфигурационный файл. При этом не отбрасывайте вариант с расширением одного конфигурационного файла, другим с помощью `extends`, более подробно о котором можно узнать из главы посвященной опциям компилятора.
