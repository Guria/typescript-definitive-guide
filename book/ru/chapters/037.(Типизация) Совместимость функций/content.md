# Совместимость функций

![Chapter Cover](./images/chapter-cover.png)

## Типизация (Function Types) - важно

Немаловажной частью при работе с функциями является понимание совместимости функциональных типов. Одни правила совместимости функциональных типов являются более очевидными, нежели другие, впервые столкнувшись с которыми, из-за отрыва их от глобального замысла, может сложится неправильное впечатление. Для того чтобы понять замысел создателей _TypeScript_ нужно детально разобрать каждый момент, но прежде стоит уточнить одну деталь. В примерах, которые будут обсуждаться в главе посвященной типизации функциональных типов, будет использоваться уточняющий шаблон `: Target = Source`, о котором шел разговор в самом начале.

Кроме того, объектные типы указанные в сигнатуре функции, ведут себя также как было описано в главе посвященной совместимости объектных типов.

## Типизация (Function Types) - совместимость параметров

Первое на что стоит обратить внимание, это параметры функции. На параметры функции приходится наибольшее количество неоднозначностей, связанных с совместимостью.

Начать стоит с того, что две сигнатуры считаются совместимыми, если они имеют равное количество параметров с совместимыми типами данных.

```typescript
type T1 = (p1: number, p2: string) => void;

let v1: T1 = (p3: number, p4: string) => {}; // Ok -> different prop identifiers
let v2: T1 = (p1: number, p2: boolean) => {}; // Error
```

При этом стоит заметить, что идентификаторы параметров не участвуют в проверке на совместимость.

```typescript
type T1 = (...rest: number[]) => void;

let v1: T1 = (...numbers: number[]) => {}; // Ok -> different prop identifiers
```

Кроме того, параметры помеченные как не обязательные, берутся в расчет только тогда, когда они участвуют в проверке на совместимость по признакам количества параметров.

```typescript
type T1 = (p1: number, p2?: string) => void;

let v1: T1 = (p1: number) => {}; // Ok
let v2: T1 = (p1: number, p2: string) => {}; // Ok or Error with active flag --strictNullChecks
let v3: T1 = (p1: number, p2: boolean) => {}; // Error
let v4: T1 = (p1: number, p2?: boolean) => {}; // Error
```

Функция которая имеет в параметрах остаточные параметры, будет двусторонне совместима с любой функцией, так как остаточные параметры расцениваются, как параметры, которые могут принадлежать к любому типу данных и чье количество находится в диапазоне от нуля до бесконечности.

```typescript
type T1 = (...rest: any[]) => void;
type T2 = (p0: number, p1: string) => void;

let v0: T1 = (...rest) => {};
let v1: T2 = (p0, p1) => {};

let v2: T1 = v1; // Ok
let v3: T2 = v0; // Ok
```

В случае, если перед остаточными параметрами объявлены обязательные параметры, то функция будет совместима с любой другой функцией, которая совместима с обязательной частью.

```typescript
type T0 = (p0: number, ...rest: any[]) => void;
type T1 = (p0: number, p1: string) => void;
type T2 = (p0: string, p1: string) => void;

let v0: T0 = (p0, ...rest) => {};
let v1: T1 = (p0, p1) => {};
let v2: T2 = (p0, p1) => {};

let v3: T0 = v1; // Ok
let v4: T1 = v0; // Ok
let v5: T2 = v0; // Error
let v6: T0 = v2; // Error
```

Следующий, один из неочевидных моментов совместимости функциональных типов, заключается в том, что сигнатура с меньшим числом параметров, совместима с сигнатурой, с большим числом параметров, но не наоборот. Это правило верно при условии соблюдения предыдущих правил относящихся к совместимости типов.

```typescript
type T0 = (p0: number, p1: string) => void;
type T1 = () => void;

let v0: T0 = () => {}; // Ok
let v1: T0 = (p: number) => {}; // Ok
let v3: T1 = (p?: number) => {}; // Ok -> optional param
let v4: T1 = (p: number) => {}; // Error -> in type S params more then in type T
```

На данный момент уже известно, что два объектных типа (`:T = S`), на основании структурной типизации, считаются совместимыми, если в типе `S` присутствуют все признаки типа `T`. Помимо этого, тип `S` может быть более специфическим чем тип `T`. Простыми словами, тип `S`, помимо всех признаков, присущих в типе `T`, также может иметь признаки, которые в типе `T` отсутствуют, но не наоборот. Простыми словами, больший тип, совместим с меньшим типом данных. В случае с параметрами функциональных типов, все с точностью наоборот.

```typescript
type T = (p0: number) => void;

let v0: T = (p0) => {}; // Ok, equal params
let v1: T = () => {}; // Ok, less params
let v2: T = (p0, p1) => {}; // Error, more params
```

Такое поведение проще всего объяснить на примере работы с методами массива. За основу будет взят метод `forEach`, из библиотеки _TypeScript_.

```typescript
forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
```

В данном случае нужно обратить внимание на функциональный тип первого параметра, в котором задекларировано три других параметра.

```typescript
callbackfn: (value: T, index: number, array: T[]) => void
```

Если бы функциональный тип с большим числом параметров не был совместим с функциональным типом с меньшим числом параметров, то при работе с методом forEach, при необходимости только в одном, первом параметре, обязательно бы приходилось создавать callback со всеми, тремя параметрами, что привело бы к излишнему коду.

```typescript
class Animal {
    name: string;
}
class Elephant extends Animal {}
class Lion extends Animal {}

let animalAll: Animal[] = [new Elephant(), new Lion()];

let nameAnimalAll: string[] = [];

animalAll.forEach((value, index, source) => nameAnimalAll.push(value.name)); // Bad
animalAll.forEach((value) => nameAnimalAll.push(value.name)); // Good
```

Кроме того, обобщенные функции, чьим параметрам в качестве типа указан параметр типа, проверяются на совместимость, по стандартному сценарию.

```typescript
function f0<T>(p0: T): void {}
function f1<T, S>(p0: T, p1: S): void {}

type T0 = typeof f0;
type T1 = typeof f1;

let v0: T0 = f1; // Error
let v1: T1 = f0; // Ok
```

Также стоит знать что параметры принадлежащие к конкретным типам, совместимы с параметрами, которым в качестве типов указаны параметры типа, но не наоборот.

```typescript
function f0<T>(p: T): void {}
function f1(p: number): void {}

type T0 = typeof f0;
type T1 = typeof f1;

let v0: T0 = f1; // Error, параметр типа T не совместим с параметром типа number
let v1: T1 = f0; // Ok, параметр типа number совместим с параметром типа T
```

Помимо того, что две сигнатуры считаются совместимыми, в случаях, в которых участвующие в проверке параметры, принадлежат к одному типу, они также считаются совместимыми, если параметры принадлежат к совместимым типам данных. С этим связана ещё одна неочевидность.

Как известно, в контексте объектных типов, если тип `T1` не идентичен полностью типу `T2`, и при этом тип `T1` совместим с типом `T2`, то значит тип `T2` будет совместим с типом `T1` через операцию приведение типов.

```typescript
class T0 {
    f0: number;
}
class T1 {
    f0: number;
    f1: string;
}
let v0: T0 = new T1(); // Ok -> неявное преобразование типов

let v1: T1 = new T0(); // Error
let v2: T1 = new T0() as T1; // Ok -> явное приведение типов
```

С типами в аннотации параметров функций все тоже самое, только не требуется явного преобразование типов. Такое поведение называется бивариантностью (глава [“Экскурс в типизацию - Совместимость типов на основе вариантности”]()) параметров и создано для того, чтобы сохранить совместимость с распространенными в _JavaScript_ практиками.

```typescript
class T0 {
    f0: number;
}
class T1 {
    f0: number;
    f1: string;
}

function f0(p: T1): void {}
function f1(p: T0): void {}

type FT0 = typeof f0;
type FT1 = typeof f1;

// бивариантное поведение

let v0: FT0 = f1; // Ok, параметр с типом T1 совместим с параметром принадлежащим к типу T0. Кроме того, тип T1 совместим с типом T0.
let v1: FT1 = f0; // Ok, параметр с типом T0 совместим с параметром принадлежащем к типу T1. Но тип T0 не совместим с типом T1  без явного приведения.
```

Изменить поведение бивариантного сопоставления параметров можно с помощью опции компилятора `--strictFunctionTypes`. Установив флаг `--strictFunctionTypes` в `true`, сопоставление будет происходить по контрвариантным правилам (глава [“Экскурс в типизацию - Совместимость типов на основе вариантности”]()).

```typescript
class T0 {
    f0: number;
}
class T1 {
    f0: number;
    f1: string;
}

function f0(p: T1): void {}
function f1(p: T0): void {}

type FT0 = typeof f0;
type FT1 = typeof f1;

// контрвариантное поведение

let v0: FT0 = f1; // Ok
let v1: FT1 = f0; // Error
```

## Типизация (Function Types) - совместимость возвращаемого значения

Первое, на что стоит обратить внимание, это ожидаемое поведение при проверке на совместимость возвращаемых типов данных. Другими словами, две сигнатуры считаются совместимыми, если их типы, указанные в аннотации возвращаемого значения, совместимы по правилам структурной типизации, которой подчиняются все объекты в _TypeScript_.

```typescript
class T0 {
    f0: number;
}
class T1 {
    f0: number;
    f1: string;
}

type FT0 = () => T0;
type FT1 = () => T1;

let v0: FT0 = () => new T1(); // Ok
let v1: FT1 = () => new T0(); // Error
```

Исключением из этого правила составляет примитивный тип данных `void`. Как стало известно из главы посвященной типу данных `void`, в обычном режиме, он совместим только с типами `null` и `undefined`, так как они являются его подтипами. При активной опции `--strictNullChecks`, примитивный тип `void` совместим только с типом `undefined`.

```typescript
let v0: void = null; // Ok and Error with strictNullChecks
let v1: void = undefined; // Ok
```

Но это правило неверно, если тип `void` указан в аннотации возвращаемого из функции значения. В случаях, когда примитивный тип `void` указан в качестве возвращаемого из функции типа данных, он совместим со всеми типами данных, без исключения.

```typescript
type T = () => void;

let v0: T = () => 0; // Ok
let v1: T = () => ''; // Ok
let v2: T = () => true; // Ok
let v3: T = () => ({}); // Ok
```

Причину, по которой поведение типа `void`, в случаях указания его в аннотации возвращаемого из функции значения, было изменено, лучше рассмотреть на примере работы с массивом, а точнее его методом `forEach`.

Предположим, есть два массива. Первый массив состоит из элементов принадлежащих к объектному типу у которого определенно поле name. Второй массив предназначен для хранения строк, и имеет длину равную 0.

```typescript
class Animal {
    name: string;
}

let animalAll: Animal[] = [new Animal(), new Animal()];
```

Задача заключается в получении имен объектов из первого массива с последующим сохранением их во второй массив.

Для этого создадим callback-стрелочную функцию. Слева от стрелки будет расположен один параметр `value`, а справа, операция сохранения имени во второй массив с помощью метода `push`.

Если обратится к декларации метода массива `forEach`, то можно убедится, что в качестве callback’а этот метод принимает функцию, у которой отсутствует возвращаемое значение.

```typescript
forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
```

Но в нашем случае, в теле callbeck’а происходит операция добавления элемента в массив. Результатом этой операции является значение длины массива. То есть, метод push возвращает значение, принадлежащий к типу `number`, которое в свою очередь возвращается из callback (стрелочной функции) переданного в метод `forEach`, у которого callback задекларирован как возвращающий тип `void`, что противоречит возвращенному типу `number`. В данном случае отсутствие ошибки объясняется совместимостью типа `void`, используемого в функциональных типах, со всеми остальными типами.

```typescript
class Animal {
    name: string;
}

let animalAll: Animal[] = [new Animal(), new Animal()];

let nameAnimalAll: string[] = [];

animalAll.forEach((value) => nameAnimalAll.push(value.name)); // forEach ожидает () => void, а получает () => number, так как стрелочная функция ыбез тела неявно возвращает значение, возвращаемое методом push.
```

И напоследок стоит упомянуть, что две обобщенные функции считаются совместимы, если у них в аннотации возвращаемого значения указан параметр типа.

```typescript
function f0<T>(p: T): T {
    return p;
}
function f1<S>(p: S): S {
    return p;
}

type T0 = typeof f0;
type T1 = typeof f1;

let v0: T0 = f1; // Ok
let v1: T1 = f0; // Ok
```

Кроме того, параметр типа совместим с любым конкретным типом данных, но не наоборот.

```typescript
function f0<T>(p: T): T {
    return p;
}
function f1(p: number): number {
    return p;
}

type T0 = typeof f0;
type T1 = typeof f1;

let v0: T0 = f1; // Error
let v1: T1 = f0; // Ok
```
